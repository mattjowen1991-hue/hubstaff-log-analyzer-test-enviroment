<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Hubstaff Client Log Analyzer</title>
  <style>
    :root {
      --bg: #0f0a1a; --panel: #1a1025; --card: #12081c; --text: #e5e7eb;
      --muted: #a78bba; --accent: #a855f7; --accent-dim: #7c3aed; --warn: #f59e0b; --danger: #ef4444;
      --success: #22c55e; --info: #3b82f6; --border: #2d1f3d; --link: #c084fc;
    }
    * { box-sizing: border-box; margin: 0; padding: 0; }
    body { font-family: system-ui, -apple-system, sans-serif; background: var(--bg); color: var(--text); min-height: 100vh; }

    header { padding: 20px; border-bottom: 1px solid var(--border); background: linear-gradient(135deg, var(--panel) 0%, #1f1030 100%); }
    header h1 { font-size: 18px; margin-bottom: 4px; color: var(--link); }
    header p { font-size: 12px; color: var(--muted); }

    main { padding: 16px; max-width: 1400px; margin: 0 auto; }

    .card { background: var(--card); border: 1px solid var(--border); border-radius: 12px; padding: 16px; margin-bottom: 16px; overflow: visible; }

    .controls { display: flex; gap: 8px; flex-wrap: wrap; align-items: center; margin-bottom: 12px; }

    button { background: var(--panel); color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 8px 14px; font-size: 13px; font-weight: 600; cursor: pointer; transition: all 0.2s; }
    button:hover { border-color: var(--accent-dim); background: #251535; }
    button.primary { background: linear-gradient(135deg, var(--accent-dim) 0%, var(--accent) 100%); border-color: var(--accent); }
    button.primary:hover { opacity: 0.9; }

    textarea { width: 100%; height: 150px; background: #050208; color: var(--text); border: 1px solid var(--border); border-radius: 8px; padding: 12px; font-family: monospace; font-size: 11px; resize: vertical; position: relative; z-index: 1; }
    textarea:focus { outline: none; border-color: var(--accent-dim); }

    .status { font-size: 12px; color: var(--muted); margin-left: 8px; }
    .status.success { color: var(--success); }
    .status.error { color: var(--danger); }

    .toggle-row { display: flex; align-items: center; gap: 16px; margin-top: 10px; font-size: 13px; color: var(--muted); flex-wrap: wrap; }
    .toggle-row label { display: flex; align-items: center; gap: 6px; cursor: pointer; }
    .toggle-row input[type="checkbox"] { accent-color: var(--accent); }
    
    .has-tooltip { position: relative; }
    .has-tooltip .tooltip { 
      display: none; 
      position: absolute; 
      bottom: calc(100% + 8px); 
      left: 50%; 
      transform: translateX(-50%); 
      background: var(--panel); 
      border: 1px solid var(--accent); 
      border-radius: 8px; 
      padding: 10px 12px; 
      font-size: 11px; 
      color: var(--text); 
      width: 260px; 
      z-index: 1000; 
      box-shadow: 0 4px 20px rgba(0,0,0,0.5);
      line-height: 1.5;
      pointer-events: none;
    }
    .has-tooltip .tooltip::after {
      content: '';
      position: absolute;
      top: 100%;
      left: 50%;
      transform: translateX(-50%);
      border: 6px solid transparent;
      border-top-color: var(--accent);
    }
    .has-tooltip .tooltip.tooltip-bottom {
      bottom: auto;
      top: calc(100% + 8px);
    }
    .has-tooltip .tooltip.tooltip-bottom::after {
      top: auto;
      bottom: 100%;
      border-top-color: transparent;
      border-bottom-color: var(--accent);
    }
    .has-tooltip:hover .tooltip { display: block; }
    
    .search-input-wrapper { flex: 1; position: relative; }
    .search-input-wrapper input { width: 100%; }
    .search-input-wrapper .tooltip { 
      width: 280px; 
      left: 0; 
      transform: none;
      text-align: left;
    }
    .search-input-wrapper .tooltip code {
      background: var(--bg);
      padding: 1px 5px;
      border-radius: 3px;
      font-size: 11px;
      color: var(--link);
    }
    
    .help-link { color: var(--accent); text-decoration: underline; cursor: pointer; margin-left: auto; }

    .filter-row { display: flex; gap: 8px; flex-wrap: wrap; margin-top: 10px; }
    .filter-btn { padding: 4px 10px; font-size: 11px; border-radius: 20px; }
    .filter-btn.active { background: var(--accent); border-color: var(--accent); color: #fff; }

    .kpis { display: grid; grid-template-columns: repeat(auto-fit, minmax(130px, 1fr)); gap: 12px; margin-bottom: 16px; }
    .kpi { background: linear-gradient(135deg, var(--panel) 0%, #1a1028 100%); border: 1px solid var(--border); border-radius: 10px; padding: 14px; }
    .kpi-label { font-size: 11px; color: var(--muted); font-weight: 600; margin-bottom: 6px; }
    .kpi-value { font-size: 22px; font-weight: 700; color: var(--link); }
    .kpi-value.danger { color: var(--danger); }
    .kpi-value.warn { color: var(--warn); }
    .kpi-value.success { color: var(--success); }

    .section-title { font-size: 13px; color: var(--muted); margin-bottom: 10px; font-weight: 600; display: flex; align-items: center; gap: 8px; }
    .section-title span { color: var(--accent); }

    .collapsible-section { border: 1px solid var(--border); border-radius: 10px; margin-bottom: 12px; overflow: hidden; background: var(--card); }
    .collapsible-header { 
      display: flex; 
      align-items: center; 
      justify-content: space-between;
      padding: 12px 16px; 
      background: var(--panel); 
      cursor: pointer; 
      user-select: none;
      transition: background 0.2s;
    }
    .collapsible-header:hover { background: #251535; }
    .collapsible-header h3 { 
      font-size: 13px; 
      font-weight: 600; 
      color: var(--text); 
      display: flex; 
      align-items: center; 
      gap: 8px; 
      margin: 0;
    }
    .collapsible-header h3 span { color: var(--accent); }
    .collapsible-header .header-meta { display: flex; align-items: center; gap: 12px; }
    .collapsible-header .badge { 
      background: var(--accent-dim); 
      color: #fff; 
      padding: 2px 8px; 
      border-radius: 10px; 
      font-size: 11px; 
      font-weight: 600;
    }
    .collapsible-header .badge.danger { background: var(--danger); }
    .collapsible-header .badge.warn { background: var(--warn); color: #000; }
    .collapsible-header .badge.success { background: var(--success); }
    .collapsible-header .chevron { 
      color: var(--muted); 
      transition: transform 0.2s; 
      font-size: 18px;
    }
    .collapsible-header.collapsed .chevron { transform: rotate(-90deg); }
    .collapsible-content { padding: 16px; }
    .collapsible-content.collapsed { display: none; }

    .table-wrap { max-height: 400px; overflow: auto; border: 1px solid var(--border); border-radius: 8px; }
    table { width: 100%; border-collapse: collapse; font-size: 12px; }
    th, td { padding: 8px 10px; text-align: left; border-bottom: 1px solid var(--border); }
    th { background: var(--panel); color: var(--muted); font-weight: 600; position: sticky; top: 0; z-index: 10; }
    tr:last-child td { border-bottom: none; }
    tr:hover { background: rgba(168,85,247,0.05); }

    .tag { display: inline-block; padding: 2px 8px; border-radius: 4px; font-size: 10px; font-weight: 600; text-transform: uppercase; }
    .tag.error { background: rgba(239,68,68,0.15); color: var(--danger); }
    .tag.warn { background: rgba(245,158,11,0.15); color: var(--warn); }
    .tag.info { background: rgba(59,130,246,0.15); color: var(--info); }
    .tag.success { background: rgba(34,197,94,0.15); color: var(--success); }
    .tag.audit { background: rgba(168,85,247,0.15); color: var(--accent); }
    .tag.trace { background: rgba(107,114,128,0.15); color: #9ca3af; }
    .tag.debug { background: rgba(107,114,128,0.1); color: #6b7280; }

    .grid-2 { display: grid; grid-template-columns: 1fr 1fr; gap: 16px; }
    @media (max-width: 900px) { .grid-2 { grid-template-columns: 1fr; } }

    .log-line { font-family: monospace; font-size: 11px; line-height: 1.6; word-break: break-all; }
    .log-line .ts { color: var(--muted); }
    .log-line .level { font-weight: 600; }
    .log-line .src { color: var(--accent-dim); }
    .log-line .msg { color: var(--text); }

    .category-header { background: var(--panel); padding: 10px 12px; font-size: 12px; font-weight: 600; color: var(--link); border-bottom: 1px solid var(--border); display: flex; justify-content: space-between; align-items: center; cursor: pointer; }
    .category-header:hover { background: #251535; }
    .category-count { background: var(--accent-dim); color: #fff; padding: 2px 8px; border-radius: 10px; font-size: 10px; }
    .category-content { max-height: 300px; overflow-y: auto; }
    .category-content.collapsed { display: none; }

    .event-item { padding: 10px 12px; border-bottom: 1px solid var(--border); font-size: 12px; }
    .event-item:last-child { border-bottom: none; }
    .event-item:hover { background: rgba(168,85,247,0.05); }
    .event-time { color: var(--muted); font-size: 11px; margin-bottom: 4px; }
    .event-detail { color: var(--text); }
    .event-context { color: var(--muted); font-size: 10px; margin-top: 4px; font-family: monospace; }

    .modal-overlay { display: none; position: fixed; inset: 0; background: rgba(0,0,0,0.8); z-index: 1001; align-items: center; justify-content: center; }
    .modal-overlay.visible { display: flex; }
    /* Help Guide Styles */
    .help-guide { max-width: 900px; max-height: 90vh; }
    .help-nav { display: flex; gap: 8px; flex-wrap: wrap; margin-bottom: 20px; padding-bottom: 16px; border-bottom: 1px solid var(--border); }
    .help-nav-btn { background: var(--panel); border: 1px solid var(--border); color: var(--muted); padding: 8px 14px; border-radius: 6px; cursor: pointer; font-size: 12px; font-weight: 600; transition: all 0.2s; }
    .help-nav-btn:hover { border-color: var(--accent); color: var(--text); }
    .help-nav-btn.active { background: var(--accent); border-color: var(--accent); color: #000; }
    .help-section { display: none; }
    .help-section.active { display: block; }
    .help-section h3 { color: var(--accent); margin: 20px 0 12px; font-size: 15px; border-bottom: 1px solid var(--border); padding-bottom: 8px; }
    .help-section h3:first-child { margin-top: 0; }
    .help-section h4 { color: var(--link); margin: 16px 0 8px; font-size: 13px; }
    .help-section p { margin: 8px 0; line-height: 1.6; }
    .help-section ul { margin: 8px 0 16px 20px; }
    .help-section li { margin: 6px 0; line-height: 1.5; }
    .help-section code { background: var(--bg); padding: 2px 6px; border-radius: 4px; font-size: 11px; color: var(--accent); }
    .help-table { width: 100%; border-collapse: collapse; margin: 12px 0; font-size: 12px; }
    .help-table th, .help-table td { padding: 10px 12px; text-align: left; border: 1px solid var(--border); }
    .help-table th { background: var(--panel); color: var(--muted); font-weight: 600; }
    .help-table tr:hover { background: rgba(168,85,247,0.05); }
    .help-callout { background: rgba(168,85,247,0.1); border-left: 3px solid var(--accent); padding: 12px 16px; border-radius: 0 8px 8px 0; margin: 16px 0; }
    .help-callout.warning { background: rgba(245,158,11,0.1); border-left-color: var(--warn); }
    .help-callout.success { background: rgba(34,197,94,0.1); border-left-color: var(--success); }
    .help-callout.danger { background: rgba(239,68,68,0.1); border-left-color: var(--danger); }
    .modal { background: var(--bg); border: 1px solid var(--border); border-radius: 12px; width: 90%; max-width: 700px; max-height: 85vh; overflow-y: auto; padding: 24px; }
    .modal h2 { color: var(--link); margin-bottom: 16px; font-size: 18px; }
    .modal h3 { color: var(--accent); margin: 20px 0 10px; font-size: 14px; border-bottom: 1px solid var(--border); padding-bottom: 6px; }
    .modal p, .modal li { font-size: 13px; color: var(--muted); line-height: 1.6; margin-bottom: 8px; }
    .modal code { background: var(--card); padding: 2px 6px; border-radius: 4px; font-size: 12px; color: var(--accent); }
    .close-btn { float: right; background: var(--panel); border: 1px solid var(--border); color: var(--text); padding: 6px 12px; border-radius: 6px; cursor: pointer; font-size: 12px; }
    .close-btn:hover { border-color: var(--accent-dim); }

    .filter-stats-box {
      margin-top: 10px;
      padding: 10px 14px;
      background: rgba(168,85,247,0.1);
      border: 1px solid var(--accent-dim);
      border-radius: 8px;
      font-size: 12px;
    }
    .filter-stats-header {
      display: flex;
      justify-content: space-between;
      align-items: center;
      color: var(--text);
    }
    .filter-toggle {
      color: var(--accent);
      cursor: pointer;
      text-decoration: underline;
      font-size: 11px;
    }
    .filter-toggle:hover { color: var(--link); }
    .filter-details {
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px dashed var(--border);
      font-size: 11px;
      color: var(--muted);
    }
    .filter-details ul {
      margin: 8px 0 8px 20px;
    }
    .filter-details li {
      margin: 4px 0;
    }
    .filter-details code {
      background: var(--bg);
      padding: 1px 5px;
      border-radius: 3px;
      color: var(--link);
      font-size: 10px;
    }

    .search-box { display: flex; gap: 8px; margin-bottom: 12px; }
    .search-box input { flex: 1; background: #050208; border: 1px solid var(--border); border-radius: 6px; padding: 8px 12px; color: var(--text); font-size: 13px; }
    .search-box input:focus { outline: none; border-color: var(--accent-dim); }
    .search-box input::placeholder { color: #4a3a5a; }

    .highlight { background: rgba(245,158,11,0.3) !important; }

    .timeline-section { margin-bottom: 16px; }
    .timeline-header { display: flex; align-items: center; gap: 16px; margin-bottom: 12px; flex-wrap: wrap; }
    .timeline-legend { font-size: 11px; color: var(--muted); display: flex; gap: 10px; flex-wrap: wrap; }
    .legend-toggle { display: flex; align-items: center; gap: 4px; cursor: pointer; padding: 3px 8px; border-radius: 4px; transition: all 0.2s; user-select: none; }
    .legend-toggle:hover { background: rgba(168,85,247,0.1); }
    .legend-toggle input { accent-color: var(--accent); cursor: pointer; }
    .legend-toggle.disabled { opacity: 0.4; }
    .legend-box { width: 12px; height: 12px; border-radius: 2px; }

    .zoom-controls { display: flex; align-items: center; gap: 8px; margin-left: auto; background: var(--panel); padding: 6px 12px; border-radius: 6px; border: 1px solid var(--border); }
    .zoom-controls label { font-size: 11px; color: var(--muted); }
    .zoom-controls input[type=range] { width: 100px; cursor: pointer; accent-color: var(--accent); }

    .timeline-container { background: rgba(0,0,0,0.3); border: 1px solid var(--border); border-radius: 8px; padding: 16px; overflow-x: auto; position: relative; }
    .timeline-content { position: relative; min-width: 100%; }
    .timeline-track { position: relative; height: 28px; background: rgba(255,255,255,0.02); border-radius: 4px; margin-bottom: 8px; border: 1px solid var(--border); transition: all 0.2s; }
    .timeline-track.hidden { display: none; }
    .timeline-label { font-size: 10px; color: var(--muted); margin-bottom: 4px; font-weight: 600; text-transform: uppercase; display: flex; justify-content: space-between; transition: all 0.2s; }
    .timeline-label.hidden { display: none; }
    .timeline-label .count { color: var(--accent); }

    .t-marker { position: absolute; top: 50%; transform: translate(-50%, -50%); width: 10px; height: 10px; border-radius: 50%; cursor: pointer; transition: transform 0.15s; z-index: 10; }
    .t-marker:hover { transform: translate(-50%, -50%) scale(1.5); z-index: 20; }
    .t-marker.error { background: var(--danger); box-shadow: 0 0 6px var(--danger); }
    .t-marker.warn { background: var(--warn); box-shadow: 0 0 6px var(--warn); }
    .t-marker.screenshot { background: var(--accent); box-shadow: 0 0 6px var(--accent); }
    .t-marker.network { background: var(--info); box-shadow: 0 0 6px var(--info); }
    .t-marker.location { background: #10b981; box-shadow: 0 0 6px #10b981; }
    .t-marker.tracking { background: var(--link); box-shadow: 0 0 6px var(--link); }

    .timeline-time-axis { display: flex; justify-content: space-between; font-size: 9px; color: var(--muted); margin-top: 8px; padding: 0 4px; }

    .info-box { position: absolute; background: var(--panel); border: 1px solid var(--accent); border-radius: 10px; padding: 14px; z-index: 1000; display: none; box-shadow: 0 10px 40px rgba(0,0,0,0.6); min-width: 220px; max-width: 350px; }
    .info-box h4 { color: var(--accent); font-size: 13px; margin-bottom: 8px; padding-bottom: 6px; border-bottom: 1px solid var(--border); }
    .info-box p { font-size: 12px; color: var(--text); margin: 4px 0; line-height: 1.5; }
    .info-box .label { color: var(--muted); }
    .info-box .msg { font-family: monospace; font-size: 10px; background: var(--bg); padding: 8px; border-radius: 4px; margin-top: 8px; max-height: 100px; overflow-y: auto; word-break: break-all; }

    .summary-item { padding: 12px; margin-bottom: 10px; border-radius: 8px; border-left: 3px solid var(--border); }
    .summary-item.critical { background: rgba(239,68,68,0.1); border-left-color: var(--danger); }
    .summary-item.warning { background: rgba(245,158,11,0.1); border-left-color: var(--warn); }
    .summary-item.info { background: rgba(168,85,247,0.1); border-left-color: var(--accent); }
    .summary-item.success { background: rgba(34,197,94,0.1); border-left-color: var(--success); }
    .summary-item h4 { font-size: 13px; margin-bottom: 6px; display: flex; align-items: center; gap: 8px; }
    .summary-item p { font-size: 12px; color: var(--muted); margin: 4px 0; line-height: 1.5; }
    .summary-item .action { font-size: 11px; color: var(--link); margin-top: 8px; padding-top: 8px; border-top: 1px dashed var(--border); }
    .summary-item .tech-detail { font-size: 10px; color: #666; font-family: monospace; margin-top: 6px; padding: 6px; background: rgba(0,0,0,0.2); border-radius: 4px; display: none; }
    .summary-item .tech-detail.visible { display: block; }
    /* Device Status Dashboard Styles */
    .device-dashboard {
      background: linear-gradient(135deg, var(--panel) 0%, #1a1028 100%);
      border: 1px solid var(--accent-dim);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 16px;
    }
    .dashboard-header {
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      margin-bottom: 16px;
      padding-bottom: 12px;
      border-bottom: 1px solid var(--border);
    }
    .dashboard-user-info h3 {
      color: var(--link);
      font-size: 16px;
      margin: 0 0 4px 0;
    }
    .dashboard-user-info p {
      color: var(--muted);
      font-size: 12px;
      margin: 2px 0;
    }
    .dashboard-device-info {
      text-align: right;
      font-size: 12px;
      color: var(--muted);
    }
    .dashboard-device-info .device-model {
      color: var(--text);
      font-weight: 600;
    }
    .dashboard-grid {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 12px;
      margin-bottom: 16px;
    }
    .dashboard-card {
      background: rgba(0,0,0,0.3);
      border: 1px solid var(--border);
      border-radius: 8px;
      padding: 12px;
    }
    .dashboard-card h4 {
      font-size: 11px;
      color: var(--muted);
      text-transform: uppercase;
      margin: 0 0 10px 0;
      font-weight: 600;
    }
    .dashboard-card .status-row {
      display: flex;
      align-items: center;
      gap: 8px;
      font-size: 12px;
      margin: 6px 0;
    }
    .dashboard-card .status-icon { font-size: 14px; }
    .dashboard-card .status-icon.success { color: var(--success); }
    .dashboard-card .status-icon.warning { color: var(--warn); }
    .dashboard-card .status-icon.error { color: var(--danger); }
    .dashboard-card .status-label { color: var(--text); }
    .dashboard-card .status-value { color: var(--muted); margin-left: auto; font-size: 11px; }
    
    /* Root Cause Conclusion Styles */
    .root-cause-box {
      background: linear-gradient(135deg, rgba(239,68,68,0.1) 0%, rgba(245,158,11,0.1) 100%);
      border: 2px solid var(--warn);
      border-radius: 12px;
      padding: 20px;
      margin-bottom: 16px;
    }
    .root-cause-box.success {
      background: linear-gradient(135deg, rgba(34,197,94,0.1) 0%, rgba(59,130,246,0.1) 100%);
      border-color: var(--success);
    }
    .root-cause-box h3 {
      color: var(--warn);
      font-size: 16px;
      margin: 0 0 12px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .root-cause-box.success h3 { color: var(--success); }
    .root-cause-box .conclusion {
      font-size: 15px;
      color: var(--text);
      line-height: 1.6;
      margin-bottom: 12px;
    }
    .root-cause-box .conclusion strong {
      color: var(--link);
    }
    .root-cause-box .evidence {
      background: rgba(0,0,0,0.3);
      border-radius: 8px;
      padding: 12px;
      margin-top: 12px;
    }
    .root-cause-box .evidence h4 {
      font-size: 12px;
      color: var(--muted);
      margin: 0 0 8px 0;
    }
    .root-cause-box .evidence ul {
      margin: 0;
      padding-left: 20px;
      font-size: 12px;
      color: var(--text);
    }
    .root-cause-box .evidence li {
      margin: 4px 0;
    }
    .root-cause-box .action-steps {
      margin-top: 12px;
      padding-top: 12px;
      border-top: 1px dashed var(--border);
    }
    .root-cause-box .action-steps h4 {
      font-size: 12px;
      color: var(--success);
      margin: 0 0 8px 0;
    }
    .root-cause-box .action-steps ol {
      margin: 0;
      padding-left: 20px;
      font-size: 12px;
      color: var(--text);
    }
    .root-cause-box .action-steps li {
      margin: 4px 0;
    }
    /* Job Sites Table Styles */
    .job-sites-summary {
      background: rgba(16, 185, 129, 0.1);
      border: 1px solid #10b981;
      border-radius: 8px;
      padding: 14px;
      margin-bottom: 12px;
    }
    .job-sites-summary h4 {
      color: #10b981;
      font-size: 13px;
      margin: 0 0 10px 0;
    }
    .job-sites-summary .stats-row {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      font-size: 12px;
      margin-bottom: 10px;
    }
    .job-sites-summary .stat {
      display: flex;
      align-items: center;
      gap: 6px;
    }
    .job-sites-summary .stat-value {
      font-weight: 600;
      color: var(--text);
    }
    .job-sites-summary .stat-label {
      color: var(--muted);
    }
    .job-sites-table {
      max-height: 250px;
      overflow-y: auto;
      border: 1px solid var(--border);
      border-radius: 6px;
      margin-top: 10px;
    }
    .job-sites-table table {
      font-size: 11px;
    }
    .job-sites-table th {
      background: var(--panel);
      position: sticky;
      top: 0;
    }
    .radius-small { color: var(--warn); }
    .radius-ok { color: var(--success); }
    .user-location-box {
      background: rgba(168, 85, 247, 0.1);
      border: 1px solid var(--accent-dim);
      border-radius: 8px;
      padding: 12px;
      margin-top: 12px;
      font-size: 12px;
    }
    .user-location-box h4 {
      color: var(--accent);
      font-size: 12px;
      margin: 0 0 8px 0;
    }
    .user-location-box .coords {
      font-family: monospace;
      color: var(--text);
    }

    /* Timezone & Date Filter Controls */
    .filter-controls {
      display: flex;
      gap: 16px;
      flex-wrap: wrap;
      margin-top: 10px;
      padding-top: 10px;
      border-top: 1px dashed var(--border);
      align-items: center;
    }
    .tz-input-group { 
      display: flex; 
      align-items: center; 
      gap: 6px; 
      padding-right: 16px;
      border-right: 1px solid var(--border);
    }
    .tz-input-group input { 
      width: 90px; 
      background: var(--panel); 
      border: 1px solid var(--border); 
      border-radius: 4px; 
      padding: 4px 8px; 
      color: var(--text); 
      font-size: 12px; 
    }
    .tz-input-group input:focus {
      outline: none;
      border-color: var(--accent);
    }
    .date-filter-group { 
      display: flex; 
      align-items: center; 
      gap: 8px; 
      font-size: 12px; 
      color: var(--muted); 
    }
    .date-filter-group input[type="date"] { 
      background: var(--panel); 
      border: 1px solid var(--border); 
      border-radius: 4px; 
      padding: 4px 8px; 
      color: var(--text); 
      font-size: 12px; 
      color-scheme: dark; 
    }
    .date-filter-group button { padding: 4px 8px; font-size: 11px; }
    .tz-label { font-size: 11px; font-weight: 600; }

    /* Job Site Visit History Styles */
    .visit-history-box {
      background: rgba(59, 130, 246, 0.1);
      border: 1px solid var(--info);
      border-radius: 8px;
      padding: 14px;
      margin: 12px 0;
    }
    .visit-history-box h4 {
      color: var(--info);
      font-size: 13px;
      margin: 0 0 10px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .visit-history-box .visit-stats {
      display: flex;
      gap: 20px;
      flex-wrap: wrap;
      font-size: 12px;
      margin-bottom: 10px;
      padding-bottom: 10px;
      border-bottom: 1px dashed var(--border);
    }
    .visit-entry {
      display: flex;
      align-items: flex-start;
      gap: 10px;
      padding: 10px 12px;
      margin: 6px 0;
      background: rgba(0,0,0,0.2);
      border-radius: 6px;
      font-size: 11px;
    }
    .visit-entry .visit-icon {
      font-size: 16px;
      margin-top: 2px;
    }
    .visit-entry .visit-details {
      flex: 1;
    }
    .visit-entry .visit-time {
      color: var(--text);
      font-weight: 600;
      font-size: 12px;
    }
    .visit-entry .visit-coords {
      color: var(--muted);
      font-size: 10px;
      font-family: monospace;
      margin-top: 4px;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .visit-entry .visit-site-info {
      margin-top: 8px;
      padding-top: 8px;
      border-top: 1px dashed var(--border);
    }
    .visit-entry .visit-site-name {
      color: var(--info);
      font-size: 11px;
      font-weight: 600;
    }
    .visit-entry .visit-distance {
      font-size: 11px;
      margin-top: 4px;
    }
    .visit-entry .visit-distance.inside { color: var(--success); }
    .visit-entry .visit-distance.outside { color: var(--danger); }
    .visit-entry .visit-accuracy {
      font-size: 10px;
      padding: 2px 6px;
      border-radius: 4px;
      margin-left: auto;
      white-space: nowrap;
    }
    .visit-entry .visit-accuracy.good {
      background: rgba(34,197,94,0.2);
      color: var(--success);
    }
    .visit-entry .visit-accuracy.fair {
      background: rgba(245,158,11,0.2);
      color: var(--warn);
    }
    .visit-entry .visit-accuracy.poor {
      background: rgba(239,68,68,0.2);
      color: var(--danger);
    }
    .visit-entry.enter { border-left: 3px solid var(--success); }
    .visit-entry.exit { border-left: 3px solid var(--warn); }
    .map-link {
      color: var(--link);
      text-decoration: none;
      font-size: 10px;
      padding: 2px 6px;
      background: rgba(192,132,252,0.1);
      border-radius: 4px;
      display: inline-flex;
      align-items: center;
      gap: 3px;
    }
    .map-link:hover {
      background: rgba(192,132,252,0.25);
      text-decoration: none;
    }
    .location-comparison {
      background: rgba(0,0,0,0.3);
      border-radius: 6px;
      padding: 10px;
      margin-top: 8px;
      font-size: 11px;
    }
    .location-comparison .compare-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 4px 0;
    }
    .location-comparison .compare-label {
      color: var(--muted);
    }
    .location-comparison .compare-value {
      font-family: monospace;
      color: var(--text);
    }
    
    .summary-item .show-tech { font-size: 10px; color: var(--muted); cursor: pointer; text-decoration: underline; margin-left: 8px; }

    .plain-explanation { font-size: 11px; color: var(--accent); margin-top: 4px; padding: 6px 10px; background: rgba(168,85,247,0.1); border-radius: 4px; border-left: 2px solid var(--accent); }

    .explainer-box {
      background: rgba(168,85,247,0.1);
      border: 1px solid var(--accent-dim);
      border-radius: 8px;
      padding: 12px 14px;
      margin-bottom: 12px;
      font-size: 12px;
      line-height: 1.6;
    }
    .explainer-box h4 { color: var(--accent); margin: 0 0 8px 0; font-size: 13px; }
    .explainer-box p { margin: 6px 0; color: var(--text); }
    .explainer-box .key-point { color: var(--warn); font-weight: 600; }
    .explainer-box ul { margin: 8px 0 8px 20px; color: var(--muted); }
    .explainer-box li { margin: 4px 0; }

    .legend-box-inline {
      background: rgba(0,0,0,0.2);
      padding: 10px 12px;
      border-radius: 6px;
      line-height: 1.8;
    }

    footer { text-align: center; padding: 20px; border-top: 1px solid var(--border); margin-top: 20px; font-size: 12px; color: var(--muted); }

    ::-webkit-scrollbar { width: 8px; height: 8px; }
    ::-webkit-scrollbar-track { background: var(--bg); }
    ::-webkit-scrollbar-thumb { background: var(--border); border-radius: 4px; }
    ::-webkit-scrollbar-thumb:hover { background: var(--accent-dim); }
  </style>
</head>
<body>
  <header>
    <h1>üîÆ Hubstaff Client Log Analyzer</h1>
    <p>Analyze hubstaff.log files to diagnose tracking issues, crashes, network errors, and more.</p>
    <p style="font-size:11px; color:var(--success); margin-top:4px;">üîí Privacy: All analysis happens in your browser. No data is sent anywhere.</p>
  </header>

  <main>
    <div class="card">
      <div class="controls">
        <button class="primary" id="analyzeBtn">üîç Analyze</button>
        <button id="clearBtn">Clear</button>
        <span class="status" id="status"></span>
      </div>
      <textarea id="logInput" placeholder="Paste raw hubstaff.log contents here - noise will be filtered automatically..."></textarea>
      <div class="toggle-row">
  <label class="has-tooltip"><input type="checkbox" id="autoFilter" checked> Auto-filter noise<span class="tooltip">Removes routine log lines (mouse coordinates, heartbeats, successful API calls) that don't help diagnose issues. Keeps errors, warnings, screenshots, and tracking events. Disable if you need to see every raw log line.</span></label>
  <label class="has-tooltip"><input type="checkbox" id="plainMode" checked> üéØ Plain English mode<span class="tooltip">Translates technical log messages into plain English explanations with actionable advice. Shows the Root Cause Analysis box and Quick Summary. Disable for raw technical view.</span></label>
        <label class="has-tooltip"><input type="checkbox" id="showDebug"> Show DEBUG level<span class="tooltip">DEBUG logs show detailed app operations like API calls, file reads, and internal processes. Usually only needed for deep technical investigation.</span></label>
        <label class="has-tooltip"><input type="checkbox" id="showTrace"> Show TRACE level<span class="tooltip">TRACE logs show very granular details like every mouse movement and keystroke. Creates a lot of noise - only enable if specifically needed.</span></label>
        <span class="help-link" id="helpBtn">Help & Info</span>
      </div>

      <!-- Timezone & Date Filter Controls -->
      <div class="filter-controls">
        <label class="has-tooltip" style="cursor:pointer;">
          <input type="checkbox" id="userTzMode"> Show in user's timezone
          <span class="tooltip tooltip-bottom">Convert all times from your local timezone to the user's timezone. Enter their UTC offset below. A ‚òÖ will appear next to converted times.</span>
        </label>
        <div class="tz-input-group">
          <span style="font-size:11px; color:var(--muted);">User's offset:</span>
          <input type="text" id="tzOffset" placeholder="e.g. -05:00">
          <span class="tz-label" id="tzLabel"></span>
        </div>
        <div class="date-filter-group">
          <label>Filter dates:</label>
          <input type="date" id="dateFrom" title="From date">
          <span>to</span>
          <input type="date" id="dateTo" title="To date">
          <button id="clearDates">Clear</button>
        </div>
      </div>
      
      <div id="filterStats" class="filter-stats-box" style="display:none;">
        <div class="filter-stats-header">
          <span id="filterStatsText"></span>
          <span class="filter-toggle" id="filterDetailsToggle" onclick="toggleFilterDetails()">What was removed?</span>
        </div>
        <div id="filterDetails" class="filter-details" style="display:none;">
          <p><strong>Noise patterns removed:</strong></p>
          <ul>
            <li><code>WindowsInput.cpp</code> - Mouse/keyboard coordinates logged every second</li>
            <li><code>InputExtension.h</code> - Routine input tracking checks</li>
            <li><code>Heart beat</code> - Keep-alive messages sent regularly</li>
            <li><code>Response: 200/201/204</code> - Successful API calls (we keep errors)</li>
            <li><code>Check CURL Response</code> - Routine network checks</li>
            <li><code>StorageIO.*Wrote</code> - Routine database writes (except Location/TrackedActivity)</li>
            <li><code>Storage.h.*Read</code> - Routine database reads</li>
            <li><code>HelperClient.cpp</code> - Routine extension checks (unless contains URL/APP)</li>
          </ul>
          <p><strong>Why filter?</strong> These lines appear hundreds/thousands of times and don't help diagnose issues. The "signal" (errors, warnings, screenshots, tracking events) is preserved.</p>
        </div>
      </div>
      <div class="search-box" style="margin-top:12px;">
        <div class="search-input-wrapper has-tooltip">
          <input type="text" id="searchInput" placeholder="Search logs (e.g., 'error', 'screenshot', 'URL:')...">
          <span class="tooltip tooltip-bottom">
            <strong>üîé Search Tips:</strong><br><br>
            Search through ALL log lines (even filtered ones) for specific text.<br><br>
            <strong>Useful searches:</strong><br>
            ‚Ä¢ <code>error</code> - Find all errors<br>
            ‚Ä¢ <code>URL:</code> - Find tracked websites<br>
            ‚Ä¢ <code>TITLE:</code> - Find window titles<br>
            ‚Ä¢ <code>Discard</code> - Find rejected time<br>
            ‚Ä¢ <code>screenshot</code> - Find capture events<br>
            ‚Ä¢ <code>watchdog</code> - Find freeze events<br>
            ‚Ä¢ <code>Response: 5</code> - Find server errors<br><br>
            <em>Results auto-expand below. Max 200 results shown.</em>
          </span>
        </div>
        <button id="searchBtn">Search</button>
        <button id="clearSearchBtn">Clear</button>
      </div>
    </div>

    <div class="kpis" id="kpiSection">
      <div class="kpi"><div class="kpi-label">Total Lines</div><div class="kpi-value" id="kpiTotal">0</div></div>
      <div class="kpi"><div class="kpi-label">Errors</div><div class="kpi-value danger" id="kpiErrors">0</div></div>
      <div class="kpi"><div class="kpi-label">Warnings</div><div class="kpi-value warn" id="kpiWarnings">0</div></div>
      <div class="kpi"><div class="kpi-label">Tracked Time</div><div class="kpi-value success" id="kpiTrackedTime">0:00:00</div></div>
      <div class="kpi"><div class="kpi-label">Idle Kept</div><div class="kpi-value" id="kpiIdleKept">0:00:00</div></div>
      <div class="kpi"><div class="kpi-label">Idle Discarded</div><div class="kpi-value warn" id="kpiIdleDisc">0:00:00</div></div>
      <div class="kpi"><div class="kpi-label">Timezone</div><div class="kpi-value" id="kpiTimezone">--</div></div>
      <div class="kpi"><div class="kpi-label">Log Time Span</div><div class="kpi-value" id="kpiTimeSpan">--</div></div>
    </div>

    <div id="rootCauseCard" style="display:none;"></div>
    
    <div id="deviceDashboard" style="display:none;"></div>

    <div class="card" id="summaryCard" style="display:none; border-left: 3px solid var(--accent);">
      <div class="section-title"><span>üìã</span> Quick Summary for Support</div>
      <div id="summaryContent"></div>
    </div>

    <div class="collapsible-section" id="sessionsCard" style="display:none;">
      <div class="collapsible-header" onclick="toggleSection('sessions')">
        <h3><span>‚è±Ô∏è</span> Tracking Sessions</h3>
        <div class="header-meta">
          <span class="badge" id="sessionsCount">0</span>
          <span class="chevron">‚ñº</span>
        </div>
      </div>
      <div class="collapsible-content" id="sessionsContent">
        <div id="sessionExplainer" class="explainer-box" style="display:none;"></div>
        <div class="table-wrap" style="max-height:300px;">
          <table>
            <thead><tr><th>#</th><th>Start</th><th>Stop</th><th>Duration</th><th>Stop Reason</th></tr></thead>
            <tbody id="sessionsBody"></tbody>
          </table>
        </div>
        <div id="stopReasonLegend" class="legend-box-inline" style="margin-top:10px; font-size:11px; color:var(--muted); display:none;">
          <strong>Stop Reasons:</strong> 
          <span class="tag success" style="margin-left:8px;">User stopped</span> = Normal stop, logged by app as user-initiated. 
          <span class="tag warn" style="margin-left:8px;">Went idle</span> = Idle timeout triggered. 
          <span class="tag error" style="margin-left:8px;">‚ö†Ô∏è Crashed</span> = No stop event found, likely crashed.
          <span style="margin-left:8px;">‚ö° = Very short session (&lt;30s)</span>
        </div>
        <div style="margin-top:12px; padding-top:12px; border-top:1px dashed var(--border);">
          <div class="section-title" style="margin-bottom:8px;"><span>üí§</span> Idle Time Decisions</div>
          <div class="table-wrap" style="max-height:300px;">
            <table>
              <thead><tr><th>Time</th><th>Idle Duration</th><th>Response Time</th><th>User Action</th><th>Raw Values</th></tr></thead>
              <tbody id="idleBody"></tbody>
            </table>
          </div>
        </div>
      </div>
    </div>

    <div class="card timeline-section" id="timelineSection" style="display:none;">
      <div class="timeline-header">
        <div class="section-title" style="margin:0;"><span>üìä</span> Event Timeline</div>
        <div class="timeline-legend">
          <label class="legend-toggle"><input type="checkbox" id="togErrors" checked><div class="legend-box" style="background:var(--danger)"></div> Errors</label>
          <label class="legend-toggle"><input type="checkbox" id="togWarnings" checked><div class="legend-box" style="background:var(--warn)"></div> Warnings</label>
          <label class="legend-toggle"><input type="checkbox" id="togScreenshots" checked><div class="legend-box" style="background:var(--accent)"></div> Screenshots</label>
          <label class="legend-toggle"><input type="checkbox" id="togNetwork" checked><div class="legend-box" style="background:var(--info)"></div> Network</label>
          <label class="legend-toggle"><input type="checkbox" id="togLocation" checked><div class="legend-box" style="background:#10b981"></div> Location</label>
          <label class="legend-toggle"><input type="checkbox" id="togTracking" checked><div class="legend-box" style="background:var(--link)"></div> Tracking</label>
        </div>
        <div class="zoom-controls">
          <label>Zoom:</label>
          <input type="range" id="zoomSlider" min="1" max="20" value="1" step="0.5">
          <button id="resetZoom">Reset</button>
        </div>
      </div>
      <div class="timeline-container" id="timelineContainer">
        <div class="timeline-content" id="timelineContent">
          <div class="timeline-label" id="labelErrors">Errors <span class="count" id="tlErrorCount">0</span></div>
          <div class="timeline-track" id="trackErrors"></div>
          <div class="timeline-label" id="labelWarnings">Warnings <span class="count" id="tlWarnCount">0</span></div>
          <div class="timeline-track" id="trackWarnings"></div>
          <div class="timeline-label" id="labelScreenshots">Screenshots <span class="count" id="tlScreenCount">0</span></div>
          <div class="timeline-track" id="trackScreenshots"></div>
          <div class="timeline-label" id="labelNetwork">Network <span class="count" id="tlNetCount">0</span></div>
          <div class="timeline-track" id="trackNetwork"></div>
          <div class="timeline-label" id="labelLocation">Location <span class="count" id="tlLocCount">0</span></div>
          <div class="timeline-track" id="trackLocation"></div>
          <div class="timeline-label" id="labelTracking">Tracking <span class="count" id="tlTrackCount">0</span></div>
          <div class="timeline-track" id="trackTracking"></div>
          <div class="timeline-time-axis" id="timeAxis"></div>
        </div>
      </div>
    </div>

    <div class="grid-2">
      <div class="collapsible-section">
        <div class="collapsible-header" onclick="toggleSection('errors')">
          <h3><span>üö®</span> Errors & Critical Issues</h3>
          <div class="header-meta">
            <span class="badge danger" id="errorsCount">0</span>
            <span class="chevron">‚ñº</span>
          </div>
        </div>
        <div class="collapsible-content" id="errorsContent">
          <div class="category-content" id="errorsList" style="max-height:350px; overflow-y:auto;"></div>
        </div>
      </div>

      <div class="collapsible-section">
        <div class="collapsible-header" onclick="toggleSection('warnings')">
          <h3><span>‚ö†Ô∏è</span> Warnings & Anomalies</h3>
          <div class="header-meta">
            <span class="badge warn" id="warningsCount">0</span>
            <span class="chevron">‚ñº</span>
          </div>
        </div>
        <div class="collapsible-content" id="warningsContent">
          <div class="category-content" id="warningsList" style="max-height:350px; overflow-y:auto;"></div>
        </div>
      </div>
    </div>

    <div class="collapsible-section">
      <div class="collapsible-header collapsed" onclick="toggleSection('screenshots')">
        <h3><span>üì∏</span> Screenshots & Screen Capture</h3>
        <div class="header-meta">
          <span class="badge" id="screenshotsCount">0</span>
          <span class="chevron">‚ñº</span>
        </div>
      </div>
      <div class="collapsible-content collapsed" id="screenshotsContent">
        <div class="table-wrap" style="max-height:250px;">
          <table>
            <thead><tr><th>Time</th><th>Event</th><th>Details</th></tr></thead>
            <tbody id="screenshotsBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="collapsible-section">
      <div class="collapsible-header collapsed" onclick="toggleSection('network')">
        <h3><span>üåê</span> Network & API Activity</h3>
        <div class="header-meta">
          <span class="badge" id="networkCount">0</span>
          <span class="chevron">‚ñº</span>
        </div>
      </div>
      <div class="collapsible-content collapsed" id="networkContent">
        <div class="table-wrap" style="max-height:250px;">
          <table>
            <thead><tr><th>Time</th><th>Status</th><th>Details</th></tr></thead>
            <tbody id="networkBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="collapsible-section">
      <div class="collapsible-header collapsed" onclick="toggleSection('locations')">
        <h3><span>üìç</span> Locations & Job Sites</h3>
        <div class="header-meta">
          <span class="badge" id="locationsCount">0</span>
          <span class="chevron">‚ñº</span>
        </div>
      </div>
      <div class="collapsible-content collapsed" id="locationsContent">
        <div id="visitHistorySection"></div>
        <div class="table-wrap" style="max-height:200px;">
          <table>
            <thead><tr><th>Time</th><th>Event</th><th>Details</th></tr></thead>
            <tbody id="locationsBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="collapsible-section">
      <div class="collapsible-header collapsed" onclick="toggleSection('apps')">
        <h3><span>üñ•Ô∏è</span> URLs & Applications</h3>
        <div class="header-meta">
          <span class="badge" id="appsCount">0</span>
          <span class="chevron">‚ñº</span>
        </div>
      </div>
      <div class="collapsible-content collapsed" id="appsContent">
        <div class="table-wrap" style="max-height:250px;">
          <table>
            <thead><tr><th>Time</th><th>Type</th><th>Content</th></tr></thead>
            <tbody id="appsBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="collapsible-section">
      <div class="collapsible-header collapsed" onclick="toggleSection('injected')">
        <h3><span>ü§ñ</span> Injected Input Activity</h3>
        <div class="header-meta">
          <span class="badge" id="injectedCount">0</span>
          <span class="chevron">‚ñº</span>
        </div>
      </div>
      <div class="collapsible-content collapsed" id="injectedContent">
        <div id="injectedExplainer" class="explainer-box">
          <h4>What is "Injected Input"?</h4>
          <p>Windows can detect when keyboard/mouse input comes from software rather than physical devices:</p>
          <ul>
            <li><strong>Real input (R)</strong> - Actual keyboard/mouse from the user</li>
            <li><strong>Injected input (I)</strong> - Software-generated input from another process</li>
            <li><strong>Low-integrity injected (LI)</strong> - Input from unverified/untrusted sources</li>
          </ul>
          <p><strong>Common legitimate causes:</strong> Remote desktop, accessibility tools, automation software, gaming mice/keyboards with macros, screen sharing.</p>
          <p><strong>‚ö†Ô∏è Note:</strong> Injected input is NOT automatically cheating. Many legitimate tools inject input. Look for patterns like: consistently 100% activity, same screenshots repeating, or injected input with zero real input.</p>
        </div>
        <div class="table-wrap" style="max-height:250px;">
          <table>
            <thead><tr><th>Time</th><th>Type</th><th>Details</th></tr></thead>
            <tbody id="injectedBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="collapsible-section">
      <div class="collapsible-header collapsed" onclick="toggleSection('tracking')">
        <h3><span>üìù</span> Raw Tracking Events</h3>
        <div class="header-meta">
          <span class="badge" id="trackingCount">0</span>
          <span class="chevron">‚ñº</span>
        </div>
      </div>
      <div class="collapsible-content collapsed" id="trackingContent">
        <div class="table-wrap" style="max-height:250px;">
          <table>
            <thead><tr><th>Time</th><th>Event</th><th>Details</th></tr></thead>
            <tbody id="trackingBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <div class="collapsible-section">
      <div class="collapsible-header collapsed" onclick="toggleSection('search')">
        <h3><span>üîé</span> Search Results</h3>
        <div class="header-meta">
          <span class="badge" id="searchCount">0</span>
          <span class="chevron">‚ñº</span>
        </div>
      </div>
      <div class="collapsible-content collapsed" id="searchContent">
        <div class="table-wrap" style="max-height:300px;">
          <table>
            <thead><tr><th>Time</th><th>Level</th><th>Source</th><th>Message</th></tr></thead>
            <tbody id="searchBody"></tbody>
          </table>
        </div>
      </div>
    </div>

    <footer>
      <span>Hubstaff Client Log Analyzer</span>
      <span style="margin:0 10px;">|</span>
      <span class="help-link" id="helpGuideBtn">üìñ Help Guide</span>
      <span style="margin:0 10px;">|</span>
      <span class="help-link" id="privacyBtn">üîí Privacy Info</span>
    </footer>
  </main>

  <div class="modal-overlay" id="privacyModal">
    <div class="modal" style="max-width:550px;">
      <button class="close-btn" id="closePrivacy">Close</button>
      <h2>üîí Privacy & Data Security</h2>
      <h3>Your data stays on your device</h3>
      <p>This tool runs <strong>entirely in your web browser</strong>. When you paste log data:</p>
      <ul>
        <li>‚úÖ Data is processed locally on your computer</li>
        <li>‚úÖ Nothing is sent to any server</li>
        <li>‚úÖ No data is stored in cookies or browser storage</li>
        <li>‚úÖ No tracking or analytics</li>
      </ul>
      <h3>What happens when you click "Clear"</h3>
      <ul>
        <li>The text input is emptied</li>
        <li>All parsed data is overwritten in memory</li>
        <li>All displayed results are removed</li>
        <li>A confirmation message appears</li>
      </ul>
      <h3>What happens when you close the page</h3>
      <ul>
        <li>All data is automatically cleared</li>
        <li>Nothing persists after you leave</li>
        <li>No data remains in browser history</li>
      </ul>
      <h3>Best practices</h3>
      <ul>
        <li>Click <strong>"Clear"</strong> when you're done analyzing</li>
        <li>Close the browser tab when finished</li>
        <li>Avoid sharing screenshots that show email addresses or PII</li>
      </ul>
      <div style="background:rgba(34,197,94,0.1); border:1px solid var(--success); border-radius:8px; padding:12px; margin-top:16px;">
        <p style="margin:0; color:var(--success);"><strong>‚úÖ Safe to use with sensitive logs</strong></p>
        <p style="margin:8px 0 0 0; font-size:12px;">This tool is designed for support teams handling customer data. Your logs never leave your browser.</p>
      </div>
    </div>
  </div>

  <div class="info-box" id="infoBox">
    <h4 id="infoTitle">Event Details</h4>
    <div id="infoContent"></div>
  </div>

  <div class="modal-overlay" id="helpModal">
    <div class="modal help-guide">
      <button class="close-btn" id="closeHelp">Close</button>
      <h2>üìñ Hubstaff Client Log Analyzer - Help Guide</h2>
      
      <nav class="help-nav">
        <button class="help-nav-btn active" data-section="overview">Overview</button>
        <button class="help-nav-btn" data-section="interface">Interface</button>
        <button class="help-nav-btn" data-section="idle">Idle Time</button>
        <button class="help-nav-btn" data-section="sessions">Sessions</button>
        <button class="help-nav-btn" data-section="jobsites">Job Sites</button>
        <button class="help-nav-btn" data-section="ios">iOS</button>
        <button class="help-nav-btn" data-section="android">Android</button>
        <button class="help-nav-btn" data-section="desktop">Desktop</button>
        <button class="help-nav-btn" data-section="patterns">Log Patterns</button>
      </nav>

      <!-- OVERVIEW SECTION -->
      <div class="help-section active" id="help-overview">
        <h3>What This Tool Analyzes</h3>
        <p>This analyzer is designed for <code>hubstaff.log</code> files (detailed client logs), not audit.log files. It works with logs from Windows, Mac, Linux, iOS, and Android.</p>
        
        <h4>Event Categories</h4>
        <table class="help-table">
          <tr><th>Category</th><th>What's Captured</th></tr>
          <tr><td><strong>Errors & Crashes</strong></td><td>[ERROR] events, watchdog hits, helper crashes, fatal errors</td></tr>
          <tr><td><strong>Warnings</strong></td><td>[WARN] events, discarded time, memory issues</td></tr>
          <tr><td><strong>Screenshots</strong></td><td>Capture events, uploads, failures</td></tr>
          <tr><td><strong>Network</strong></td><td>API responses (especially 4xx/5xx), connection issues</td></tr>
          <tr><td><strong>Locations</strong></td><td>Geofence events, permission states, GPS coordinates</td></tr>
          <tr><td><strong>Tracking</strong></td><td>Start/stop, idle, resume, discard events</td></tr>
        </table>

        <h3>Built-in Noise Filter</h3>
        <p>Enabled by default, this removes routine log lines that don't help with debugging:</p>
        <ul>
          <li><code>WindowsInput.cpp</code> - Mouse/keyboard coordinates</li>
          <li><code>Heart beat</code> - Keep-alive messages</li>
          <li><code>Response: 200/201/204</code> - Successful API calls</li>
          <li><code>StorageIO.*Wrote</code> - Routine database writes</li>
        </ul>
        <p>Uncheck "Auto-filter noise" if you need to see all raw log lines.</p>

        <h3>Privacy</h3>
        <div class="help-callout success">
          <strong>üîí 100% Local Processing</strong><br>
          All analysis happens in your browser. No data is ever sent to any server. Click "Clear" or close the tab to wipe all data from memory.
        </div>
      </div>

      <!-- INTERFACE SECTION -->
      <div class="help-section" id="help-interface">
        <h3>KPI Dashboard</h3>
        <table class="help-table">
          <tr><th>Metric</th><th>What It Means</th></tr>
          <tr><td><strong>Total Lines</strong></td><td>Number of log lines analyzed</td></tr>
          <tr><td><strong>Errors</strong></td><td>Count of ERROR-level events</td></tr>
          <tr><td><strong>Warnings</strong></td><td>Count of WARN-level events</td></tr>
          <tr><td><strong>Tracked Time</strong></td><td>Actual time between START and STOP events</td></tr>
          <tr><td><strong>Idle Kept</strong></td><td>Idle time the user chose to keep</td></tr>
          <tr><td><strong>Idle Discarded</strong></td><td>Idle time that was rejected</td></tr>
        </table>

        <h3>Controls</h3>
        <table class="help-table">
          <tr><th>Control</th><th>Purpose</th></tr>
          <tr><td><strong>Auto-filter noise</strong></td><td>Remove routine log lines that don't help diagnose issues</td></tr>
          <tr><td><strong>Plain English mode</strong></td><td>Show translated explanations instead of raw technical data</td></tr>
          <tr><td><strong>Show DEBUG/TRACE</strong></td><td>Include verbose logging levels (rarely needed)</td></tr>
          <tr><td><strong>Show user's timezone</strong></td><td>Convert timestamps to customer's local time (marked with ‚òÖ)</td></tr>
          <tr><td><strong>Filter dates</strong></td><td>Narrow results to a specific date range</td></tr>
        </table>

        <h3>Search Tips</h3>
        <p>The search box searches <strong>all</strong> log lines, including filtered ones:</p>
        <ul>
          <li><code>error</code> - All error mentions</li>
          <li><code>URL:</code> - Tracked websites</li>
          <li><code>screenshot</code> - Screen capture events</li>
          <li><code>Discard</code> - Rejected time</li>
          <li><code>watchdog</code> - App freeze events</li>
          <li><code>Response: 5</code> - Server errors (5xx)</li>
        </ul>
      </div>

      <!-- IDLE TIME SECTION -->
      <div class="help-section" id="help-idle">
        <h3>Idle Time Decisions Table</h3>
        <p>This table shows <strong>every idle prompt response</strong> with full details. Use it when a customer claims they clicked "Yes" to keep idle time.</p>
        
        <table class="help-table">
          <tr><th>Column</th><th>Description</th></tr>
          <tr><td><strong>Time</strong></td><td>When the user responded to the idle prompt</td></tr>
          <tr><td><strong>Idle Duration</strong></td><td>How long the user was idle before responding</td></tr>
          <tr><td><strong>Response Time</strong></td><td>How many seconds the user took to answer</td></tr>
          <tr><td><strong>User Action</strong></td><td>What the user chose (KEPT, DISCARDED, etc.)</td></tr>
          <tr><td><strong>Raw Values</strong></td><td>The actual KeepIdle/StopTracking values from the log</td></tr>
        </table>

        <h4>User Action Types</h4>
        <table class="help-table">
          <tr><th>Display</th><th>Raw Values</th><th>Meaning</th></tr>
          <tr><td>‚úÖ KEPT</td><td><code>KeepIdle: 1 / StopTracking: 0</code></td><td>User clicked YES to keep idle time</td></tr>
          <tr><td>‚ùå DISCARDED</td><td><code>KeepIdle: 0 / StopTracking: 0</code></td><td>User clicked NO but continued tracking</td></tr>
          <tr><td>üõë DISCARDED + STOPPED</td><td><code>KeepIdle: 0 / StopTracking: 1</code></td><td>User clicked NO and stopped tracking</td></tr>
        </table>

        <div class="help-callout warning">
          <strong>‚ö†Ô∏è 1-Hour Limit</strong><br>
          If idle duration exceeds 1 hour, a warning badge appears. Idle time over 1 hour <strong>cannot be kept</strong> regardless of user choice - this is a system limitation.
        </div>

        <h4>Investigating "I Clicked Yes But Time Wasn't Kept"</h4>
        <ol>
          <li>Find the date/time in the Idle Time Decisions table</li>
          <li>Check the <strong>Raw Values</strong> column</li>
          <li>If <code>KeepIdle: 1</code> ‚Üí Client recorded YES correctly. Issue is server-side.</li>
          <li>If <code>KeepIdle: 0</code> ‚Üí User actually clicked NO (or prompt timed out)</li>
          <li>If <strong>>1hr badge</strong> shows ‚Üí Time exceeded limit, can't be kept even with YES</li>
        </ol>
      </div>

      <!-- SESSIONS SECTION -->
      <div class="help-section" id="help-sessions">
        <h3>Tracking Sessions</h3>
        <p>The sessions table shows each START/STOP pair with duration and stop reason.</p>

        <h4>Stop Reasons</h4>
        <table class="help-table">
          <tr><th>Stop Reason</th><th>Meaning</th><th>Problem?</th></tr>
          <tr><td><strong>User stopped</strong></td><td>Normal stop, logged as user-initiated</td><td>No</td></tr>
          <tr><td><strong>Went idle</strong></td><td>Idle timeout triggered</td><td>No</td></tr>
          <tr><td><strong>‚ö†Ô∏è Crashed</strong></td><td>No stop event found, app likely crashed</td><td>Yes - investigate</td></tr>
          <tr><td><strong>Config/Limit</strong></td><td>Policy stopped tracking (time limit, schedule)</td><td>Check settings</td></tr>
          <tr><td><strong>üìç Left Job Site</strong></td><td>User exited geofenced area</td><td>Expected if rules active</td></tr>
          <tr><td><strong>App closed</strong></td><td>App was shut down normally</td><td>No</td></tr>
        </table>

        <div class="help-callout">
          <strong>What "User stopped" Does NOT Mean</strong><br>
          ‚ùå Does NOT mean the app crashed<br>
          ‚ùå Does NOT mean there was an error<br>
          ‚ùå Does NOT mean timezone issues caused it<br>
          If user disputes stopping manually: consider accidental click, trackpad sensitivity, or another person with access.
        </div>
      </div>

      <!-- JOB SITES SECTION -->
      <div class="help-section" id="help-jobsites">
        <h3>Job Site Analysis</h3>
        <p>When job site data is present, you'll see configured sites, user location, and visit history with map links.</p>

        <h4>Visit History</h4>
        <p>Each entry shows:</p>
        <ul>
          <li>User's GPS coordinates at the time</li>
          <li>Distance to nearest configured site</li>
          <li>Whether inside or outside the radius</li>
          <li><strong>Map links</strong> to view in Google Maps</li>
        </ul>

        <h4>Recommended Job Site Radius</h4>
        <table class="help-table">
          <tr><th>Scenario</th><th>Recommended Radius</th></tr>
          <tr><td>Outdoor work</td><td>50-100m</td></tr>
          <tr><td>Indoor office</td><td>100-150m</td></tr>
          <tr><td>Large facility</td><td>150-200m</td></tr>
          <tr><td>Poor GPS area</td><td>200m+</td></tr>
        </table>

        <div class="help-callout warning">
          <strong>‚ö†Ô∏è Radius ‚â§50m Warning</strong><br>
          Job sites with very small radii often fail due to GPS accuracy limitations, especially indoors.
        </div>

        <h4>Primary Device</h4>
        <p>Only the <strong>primary device</strong> can record locations and trigger job site automations. If you see "not primary" errors:</p>
        <ul>
          <li>User logged into a newer device, making the old one non-primary</li>
          <li>A banner should appear on Timer screen to "Make Primary"</li>
        </ul>
      </div>

      <!-- iOS SECTION -->
      <div class="help-section" id="help-ios">
        <h3>iOS Location Troubleshooting</h3>
        <h4>Required Settings</h4>
        <ol>
          <li><strong>Location Services:</strong> Settings ‚Üí Privacy & Security ‚Üí Location Services ‚Üí ON</li>
          <li><strong>Hubstaff Permission:</strong> Settings ‚Üí Hubstaff ‚Üí Location ‚Üí <code>Always</code></li>
          <li><strong>Precise Location:</strong> Settings ‚Üí Hubstaff ‚Üí Precise Location ‚Üí ON</li>
          <li><strong>Background Refresh:</strong> Settings ‚Üí General ‚Üí Background App Refresh ‚Üí Hubstaff ‚Üí ON</li>
        </ol>

        <div class="help-callout danger">
          <strong>‚ö†Ô∏è "While Using" Is NOT Sufficient</strong><br>
          Hubstaff requires "Always" permission to track locations in the background. "While Using" will cause job sites to fail.
        </div>

        <h4>Common iOS Log Patterns</h4>
        <table class="help-table">
          <tr><th>Pattern</th><th>Meaning</th></tr>
          <tr><td><code>kCLErrorDomain Code=1</code></td><td>Location permission denied</td></tr>
          <tr><td><code>kCLErrorDomain Code=0</code></td><td>Location unknown/unavailable</td></tr>
          <tr><td><code>Background Refresh: OFF</code></td><td>Background app refresh disabled</td></tr>
        </table>
      </div>

      <!-- ANDROID SECTION -->
      <div class="help-section" id="help-android">
        <h3>Android Location Troubleshooting</h3>
        <h4>Required Settings</h4>
        <ol>
          <li><strong>Location Permission:</strong> Settings ‚Üí Apps ‚Üí Hubstaff ‚Üí Permissions ‚Üí Location ‚Üí "Allow all the time"</li>
          <li><strong>Location Mode:</strong> Enable "High accuracy" mode</li>
          <li><strong>Battery Optimization:</strong> Settings ‚Üí Apps ‚Üí Hubstaff ‚Üí Battery ‚Üí "Unrestricted"</li>
        </ol>

        <h4>Brand-Specific Battery Settings (CRITICAL)</h4>
        <table class="help-table">
          <tr><th>Brand</th><th>Steps</th></tr>
          <tr><td><strong>Samsung</strong></td><td>Device Care ‚Üí Battery ‚Üí App power management ‚Üí Hubstaff ‚Üí Unrestricted. Remove from "Sleeping apps" AND "Deep sleeping apps"</td></tr>
          <tr><td><strong>Xiaomi/MIUI</strong></td><td>Apps ‚Üí Manage Apps ‚Üí Hubstaff ‚Üí Autostart ON. Battery ‚Üí Hubstaff ‚Üí No restrictions</td></tr>
          <tr><td><strong>Huawei</strong></td><td>Battery ‚Üí App Launch ‚Üí Hubstaff ‚Üí Manually Manage with all toggles ON</td></tr>
          <tr><td><strong>OnePlus</strong></td><td>Battery ‚Üí Battery Optimization ‚Üí Hubstaff ‚Üí Don't optimize</td></tr>
          <tr><td><strong>OPPO/Realme</strong></td><td>App Management ‚Üí Hubstaff ‚Üí Allow Auto-start + disable battery optimization</td></tr>
        </table>

        <h4>Common Android Log Patterns</h4>
        <table class="help-table">
          <tr><th>Pattern</th><th>Meaning</th></tr>
          <tr><td><code>isIgnoringBatteryOptimization: false</code></td><td>Battery optimization is ON (bad)</td></tr>
          <tr><td><code>BACKGROUND_LOCATION enabled=false</code></td><td>Background location not granted</td></tr>
          <tr><td><code>TRACKING_NOT_STARTED</code></td><td>Timer blocked - not at required job site</td></tr>
          <tr><td><code>non-primary device</code></td><td>Different device is set as primary</td></tr>
        </table>
      </div>

      <!-- DESKTOP SECTION -->
      <div class="help-section" id="help-desktop">
        <h3>Windows/Mac/Linux Desktop</h3>
        <h4>Common Issues</h4>
        <table class="help-table">
          <tr><th>Pattern</th><th>Meaning</th><th>Solution</th></tr>
          <tr><td><code>main_watchdog hit</code></td><td>App froze/became unresponsive</td><td>Check system resources, restart app</td></tr>
          <tr><td><code>Helper died</code></td><td>Browser extension crashed</td><td>Reinstall extension, restart browser</td></tr>
          <tr><td><code>Response: 401</code></td><td>Authentication failed</td><td>User needs to re-login</td></tr>
          <tr><td><code>Could not resolve host</code></td><td>No internet connection</td><td>Check network connectivity</td></tr>
        </table>

        <h4>Brave Browser</h4>
        <div class="help-callout warning">
          <strong>‚ö†Ô∏è URL Tracking Not Supported in Brave</strong><br>
          Hubstaff cannot track URLs in Brave Browser. The app name will be tracked, but visited URLs will not appear in reports. For URL tracking, use Chrome, Edge, Firefox, or Island Browser.
        </div>

        <h4>Mac Permissions</h4>
        <p>If URL or screenshot tracking isn't working on Mac:</p>
        <ul>
          <li><strong>Screen Recording:</strong> System Settings ‚Üí Privacy & Security ‚Üí Screen Recording ‚Üí Enable Hubstaff</li>
          <li><strong>Accessibility:</strong> System Settings ‚Üí Privacy & Security ‚Üí Accessibility ‚Üí Enable Hubstaff</li>
          <li><strong>Automation:</strong> System Settings ‚Üí Privacy & Security ‚Üí Automation ‚Üí Enable Hubstaff for browsers</li>
        </ul>
      </div>

      <!-- LOG PATTERNS SECTION -->
      <div class="help-section" id="help-patterns">
        <h3>Key Log Patterns Cheat Sheet</h3>
        <table class="help-table">
          <tr><th>Pattern</th><th>Meaning</th></tr>
          <tr><td><code>[ERROR]</code></td><td>Something went wrong</td></tr>
          <tr><td><code>[WARN]</code></td><td>Potential issue</td></tr>
          <tr><td><code>main_watchdog hit</code></td><td>App froze</td></tr>
          <tr><td><code>Helper died</code></td><td>Browser extension crashed</td></tr>
          <tr><td><code>Response: 4xx</code></td><td>Client error (auth, not found)</td></tr>
          <tr><td><code>Response: 5xx</code></td><td>Server error (outage)</td></tr>
          <tr><td><code>Discard=1</code></td><td>Time was rejected</td></tr>
          <tr><td><code>STARTUP_UNCLEAN</code></td><td>App crashed or was killed</td></tr>
          <tr><td><code>KeepIdle: 1</code></td><td>User chose to keep idle time</td></tr>
          <tr><td><code>KeepIdle: 0</code></td><td>User chose to discard idle time</td></tr>
        </table>

        <h3>Plain English Translations</h3>
        <p>When Plain English mode is enabled, common patterns are translated:</p>
        <table class="help-table">
          <tr><th>Technical Log</th><th>Plain English</th></tr>
          <tr><td><code>main_watchdog hit</code></td><td>‚ö†Ô∏è The app froze or became unresponsive</td></tr>
          <tr><td><code>Helper died</code></td><td>üîå The browser extension crashed</td></tr>
          <tr><td><code>Response: 401</code></td><td>üîê Authentication failed - user may be logged out</td></tr>
          <tr><td><code>kCLErrorDomain Code=1</code></td><td>üìç iOS Location Permission Denied</td></tr>
          <tr><td><code>TRACKING_NOT_STARTED</code></td><td>üö´ Timer Blocked - Not At Required Job Site</td></tr>
        </table>

        <h3>Workflow for Log Analysis</h3>
        <ol>
          <li>Paste logs and click Analyze</li>
          <li>Check <strong>Root Cause Analysis</strong> box first (if Plain English mode is on)</li>
          <li>Review <strong>Quick Summary</strong> for prioritized findings</li>
          <li>Check <strong>Device Dashboard</strong> (Android) for permission/setting issues</li>
          <li>Review <strong>Tracking Sessions</strong> to understand what was tracked</li>
          <li>Check <strong>Idle Time Decisions</strong> if user disputes idle choices</li>
          <li>Use <strong>Search</strong> for specific patterns if needed</li>
          <li>Check <strong>Visit History</strong> for job site issues with map links</li>
        </ol>
      </div>

    </div>
  </div>

  <script>
    const $ = id => document.getElementById(id);
    const pad = n => String(n).padStart(2, '0');

    let allLines = [];
    let fullParsedData = null; // Store unfiltered data for date filtering
    let userTzOffsetMs = null;

    // === TIMEZONE HANDLING ===
    function parseTzOffset(str) {
      if (!str || !str.trim()) return null;
      str = str.trim();
      let sign = 1;
      if (str.startsWith('-')) { sign = -1; str = str.slice(1); }
      else if (str.startsWith('+')) { str = str.slice(1); }
      let hours = 0, mins = 0;
      if (str.includes(':')) {
        const parts = str.split(':');
        hours = parseInt(parts[0]) || 0;
        mins = parseInt(parts[1]) || 0;
      } else {
        hours = parseFloat(str) || 0;
        mins = Math.round((hours - Math.floor(hours)) * 60);
        hours = Math.floor(hours);
      }
      return sign * (hours * 60 + mins) * 60 * 1000;
    }

    function updateTzLabel() {
      const offset = parseTzOffset($('tzOffset').value);
      if (offset !== null) {
        const hrs = Math.floor(Math.abs(offset) / 3600000);
        const mns = Math.floor((Math.abs(offset) % 3600000) / 60000);
        const sgn = offset >= 0 ? '+' : '-';
        $('tzLabel').textContent = 'UTC' + sgn + hrs + (mns ? ':' + pad(mns) : '');
        $('tzLabel').style.color = 'var(--success)';
        userTzOffsetMs = offset;
      } else {
        $('tzLabel').textContent = $('tzOffset').value ? '‚ö†Ô∏è Invalid' : '';
        $('tzLabel').style.color = 'var(--warn)';
        userTzOffsetMs = null;
      }
    }

    function fmtTimeWithTz(date, includeDate = false) {
      if (!date) return '--';
      
      if ($('userTzMode')?.checked && userTzOffsetMs !== null) {
        const utcMs = date.getTime() + date.getTimezoneOffset() * 60 * 1000;
        const userDate = new Date(utcMs + userTzOffsetMs);
        if (includeDate) {
          return userDate.toLocaleDateString([], {month:'short', day:'numeric', year:'numeric'}) + ' ' + 
                 userDate.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'}) + ' ‚òÖ';
        }
        return userDate.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit', second:'2-digit'}) + ' ‚òÖ';
      }
      
      if (includeDate) {
        return date.toLocaleDateString([], {month:'short', day:'numeric', year:'numeric'}) + ' ' + date.toLocaleTimeString();
      }
      return date.toLocaleTimeString();
    }

    // === DATE FILTERING ===
    function filterByDate(data) {
      if (!data) return data;
      
      const fromVal = $('dateFrom').value;
      const toVal = $('dateTo').value;
      if (!fromVal && !toVal) return data;
      
      const fromDate = fromVal ? new Date(fromVal + 'T00:00:00') : null;
      const toDate = toVal ? new Date(toVal + 'T23:59:59') : null;
      
      const filterByTs = (item) => {
        if (!item.ts) return true;
        if (fromDate && item.ts < fromDate) return false;
        if (toDate && item.ts > toDate) return false;
        return true;
      };
      
      // Recalculate idle from filtered events
      let idleKeptSecs = 0, idleDiscardedSecs = 0;
      const filteredIdleDecisions = data.idleDecisions.filter(filterByTs);
      filteredIdleDecisions.forEach(d => {
        if (d.decision === 'KEPT') idleKeptSecs += d.seconds;
        else idleDiscardedSecs += d.seconds;
      });
      
      return {
        ...data,
        errors: data.errors.filter(filterByTs),
        warnings: data.warnings.filter(filterByTs),
        screenshots: data.screenshots.filter(filterByTs),
        network: data.network.filter(filterByTs),
        locations: data.locations.filter(filterByTs),
        apps: data.apps.filter(filterByTs),
        tracking: data.tracking.filter(filterByTs),
        injected: data.injected.filter(filterByTs),
        sessions: data.sessions.filter(s => {
          if (fromDate && s.start < fromDate) return false;
          if (toDate && s.stop && s.stop > toDate) return false;
          return true;
        }),
        idleDecisions: filteredIdleDecisions,
        idleKeptSecs,
        idleDiscardedSecs,
        jobSites: data.jobSites,
        userLocations: data.userLocations.filter(filterByTs),
        currentlyEnteredSites: data.currentlyEnteredSites.filter(filterByTs),
        geofenceEvents: (data.geofenceEvents || []).filter(filterByTs)
      };
    }

    // === HAVERSINE DISTANCE (for matching user location to job sites) ===
    function haversineDistance(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const dLat = (lat2 - lat1) * Math.PI / 180;
      const dLon = (lon2 - lon1) * Math.PI / 180;
      const a = Math.sin(dLat/2) * Math.sin(dLat/2) +
                Math.cos(lat1 * Math.PI / 180) * Math.cos(lat2 * Math.PI / 180) *
                Math.sin(dLon/2) * Math.sin(dLon/2);
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1-a));
      return R * c;
    }

    function findNearestSite(lat, lng, sites) {
      let nearest = null;
      let minDist = Infinity;
      
      for (const site of sites) {
        const dist = haversineDistance(lat, lng, site.lat, site.lng);
        if (dist < minDist) {
          minDist = dist;
          nearest = { ...site, distance: Math.round(dist) };
        }
      }
      return nearest;
    }

    function generateMapLink(lat, lng, label = 'View on Map') {
      const googleUrl = `https://www.google.com/maps?q=${lat},${lng}`;
      return `<a href="${googleUrl}" target="_blank" rel="noopener" class="map-link" title="Open in Google Maps">üó∫Ô∏è ${label}</a>`;
    }
    let parsedData = null;
    let timelineMin = null;
    let timelineDur = null;
    let selectedMarker = null;

    // === iOS/LOCATION LOG PATTERNS ===
    const LOCATION_PATTERNS = {
      errors: [
        { pattern: /\[Position\] Couldn't obtain location.*denied.*Code=1/i, meaning: "üìç Location permission DENIED at iOS level", action: "User must go to iOS Settings ‚Üí Privacy & Security ‚Üí Location Services ‚Üí Hubstaff ‚Üí select 'Always'. The app requested location but iOS blocked it because permission is set to 'Never' or 'While Using'." },
        { pattern: /\[Position\] Couldn't obtain location.*Code=0/i, meaning: "üìç Location unknown - device couldn't determine position", action: "GPS signal may be weak. Have user try outdoors with clear sky view, or check if Location Services are enabled globally." },
        { pattern: /\[Position\] Couldn't obtain location/i, meaning: "üìç Device cannot access user's location", action: "Check if location services are enabled and permissions are set to 'Always'" },
        { pattern: /\[Site\] Region issue/i, meaning: "üìç Problem monitoring job site region", action: "May affect job site detection. Check location permissions and GPS signal." },
        { pattern: /\[LocationResolution\].*error/i, meaning: "üìç Failed to resolve location name", action: "Geocoding issue - may show coordinates instead of address names." },
        { pattern: /kCLErrorDomain Code=1/i, meaning: "üìç iOS Location Permission Denied (kCLErrorDomain)", action: "This iOS error means location permission is denied. Go to Settings ‚Üí Hubstaff ‚Üí Location ‚Üí 'Always'." },
        { pattern: /kCLErrorDomain Code=0/i, meaning: "üìç iOS Location Unknown (kCLErrorDomain)", action: "iOS couldn't determine location. Check GPS signal, try outdoors, ensure Location Services are ON globally." },
        // Android network/DNS errors
        { pattern: /Could not resolve host/i, meaning: "üåê DNS Resolution Failed - No Internet", action: "Device cannot reach Hubstaff servers. Check: WiFi/mobile data is ON, airplane mode is OFF, try switching networks." },
        { pattern: /Network Error.*code=6/i, meaning: "üåê Network Error Code 6 - Cannot Resolve DNS", action: "Device has no working internet connection. Network/WiFi may be connected but not working." },
        { pattern: /UnknownHostException/i, meaning: "üåê Java DNS Error - No Internet", action: "Android cannot resolve server addresses. Check internet connectivity." },
        { pattern: /Unable to update the tokens/i, meaning: "üîê Token Refresh Failed - Network Issue", action: "Could not refresh login session. Usually caused by no internet connection." },
        { pattern: /failed to request current location.*cancelled/i, meaning: "üìç Location Request Cancelled", action: "Location update was cancelled. May be due to app being backgrounded or permission issue." },
      ],
      audit: [
        { pattern: /Locations needed but non-primary device/i, meaning: "üì± Can't track - this isn't the primary device", action: "User needs to tap the banner to make this device primary, or use their primary device." },
        { pattern: /Locations needed but unavailable/i, meaning: "üìç Can't track - location not available", action: "Check: Location Services ON, Hubstaff permission set to 'Always', Precise Location ON" },
        { pattern: /Must visit.*currently at/i, meaning: "üìç Can't start timer - not at a job site", action: "User must be physically at a job site to start tracking (Restrict timer to job sites is ON)" },
        { pattern: /\[Site\] Handle.*ENTER.*passive/i, meaning: "üìç Entered job site (detected in background)", action: null },
        { pattern: /\[Site\] Handle.*ENTER.*active/i, meaning: "üìç Entered job site (while tracking)", action: null },
        { pattern: /\[Site\] Handle.*EXIT.*passive/i, meaning: "üìç Left job site (detected in background)", action: null },
        { pattern: /\[Site\] Handle.*EXIT.*active/i, meaning: "üìç Left job site (while tracking)", action: null },
        { pattern: /auto-start project/i, meaning: "‚ñ∂Ô∏è Timer auto-started by job site rule", action: null },
        { pattern: /auto-stop project/i, meaning: "‚èπÔ∏è Timer auto-stopped by job site rule", action: null },
        { pattern: /DID NOT auto-start.*was prevented/i, meaning: "‚ö†Ô∏è Job site tried to auto-start but was blocked", action: "Check logs above this for the specific reason." },
        { pattern: /DID NOT auto-start.*already tracking/i, meaning: "‚ÑπÔ∏è Job site didn't auto-start - already tracking another project", action: "Normal behavior - won't interrupt current work." },
        { pattern: /WILL NOT auto-start.*not primary/i, meaning: "üì± Job site won't auto-start - not primary device", action: "User needs to make this device primary." },
        { pattern: /DID NOT auto-stop.*is tracking project/i, meaning: "‚ÑπÔ∏è Job site didn't auto-stop - tracking different project", action: "Normal - only stops if tracking the site's configured project." },
        { pattern: /WILL NOT auto-stop.*not primary/i, meaning: "üì± Job site won't auto-stop - not primary device", action: "User needs to make this device primary." },
        { pattern: /notify reminder/i, meaning: "üîî Sent reminder notification to user", action: null },
        // Android tracking blocked events
        { pattern: /TRACKING_NOT_STARTED.*requires being at a job site/i, meaning: "üö´ Timer Blocked - Not At Required Job Site", action: "User tried to start timer but is not at a configured job site. Organization has 'Restrict timer to job sites' enabled." },
        { pattern: /Timer could not be started.*requires being at a job site/i, meaning: "üö´ Timer Blocked - Job Site Restriction", action: "The organization requires users to be physically at a job site to start tracking. User is not at any configured site." },
        // Android startup events
        { pattern: /STARTUP_UNCLEAN/i, meaning: "‚ö†Ô∏è App crashed or was force-closed last time", action: "The app didn't shut down properly. May have lost unsaved data. Check if user force-closed it or if Android killed it." },
        { pattern: /STARTUP_CLEAN/i, meaning: "‚úÖ App started normally after clean shutdown", action: null },
        { pattern: /\(FOREGROUNDED\)/i, meaning: "üì± App brought to foreground", action: null },
        { pattern: /\(BACKGROUNDED\)/i, meaning: "üì± App sent to background", action: null },
      ],
      info: [
        { pattern: /\[LocationRequest\].*not the user's primary device/i, meaning: "üì± Location request ignored - not primary device", action: "Only the primary device reports locations." },
        { pattern: /\[LocationRequest\].*locations are not available/i, meaning: "üìç Location request failed - unavailable", action: "Check location permissions and services." },
        { pattern: /\[LocationRequest\].*neither active or passive/i, meaning: "üìç Location request ignored - not recording", action: "Track Locations may be Off, or timer not running." },
        { pattern: /Discarding simulated locations/i, meaning: "üö´ Fake/simulated location detected and ignored", action: "User may be using a location spoofing app - this is blocked." },
        { pattern: /\[Site\] REGION STOP/i, meaning: "üìç Stopped monitoring a job site region", action: null },
        { pattern: /\[Site\] REGION START/i, meaning: "üìç Started monitoring a job site region", action: null },
        { pattern: /suspicious movement/i, meaning: "üöó Fast movement detected - rechecking job sites", action: "User may be driving away from site." },
        // Android permission and status patterns
        { pattern: /permission state is State.*BACKGROUND_LOCATION.*enabled=false/i, meaning: "‚ö†Ô∏è Android Background Location Permission DENIED", action: "User must enable 'Allow all the time' for location: Settings ‚Üí Apps ‚Üí Hubstaff ‚Üí Permissions ‚Üí Location." },
        { pattern: /permission state is State.*BACKGROUND_LOCATION.*enabled=true/i, meaning: "‚úÖ Android Background Location Granted", action: null },
        { pattern: /locationState is \[SERVICES_ENABLED, PERMISSIONS_ENABLED, ACCURACY_ENABLED\]/i, meaning: "‚úÖ Android Location Services Fully Enabled", action: null },
        { pattern: /isIgnoringBatteryOptimization.*=false/i, meaning: "üîã Battery Optimization ENABLED - May Kill App", action: "Disable battery optimization: Settings ‚Üí Apps ‚Üí Hubstaff ‚Üí Battery ‚Üí Unrestricted" },
        { pattern: /isIgnoringBatteryOptimization.*=true/i, meaning: "‚úÖ Battery Optimization Correctly Disabled", action: null },
        // Android geofence events
        { pattern: /handling geofence event.*transitionType=ENTER/i, meaning: "üìç Entered Geofence Area", action: null },
        { pattern: /handling geofence event.*transitionType=EXIT/i, meaning: "üìç Exited Geofence Area", action: null },
        { pattern: /updated \d+ geofences succesfully/i, meaning: "‚úÖ Job Site Geofences Registered", action: null },
        { pattern: /sites count:.*wrappers count:/i, meaning: "üìç Job Sites Loaded", action: null },
        // Android motion detection
        { pattern: /motion event.*VEHICLE/i, meaning: "üöó Driving Activity Detected", action: null },
        { pattern: /motion event.*STILL/i, meaning: "üßç Stationary Activity Detected", action: null },
      ],
      trace: [
        { pattern: /Primary changed/i, meaning: "üì± Primary device status changed", action: null },
        { pattern: /Location Availability changed/i, meaning: "üìç Location availability changed", action: null },
        { pattern: /Recording changed/i, meaning: "üìç Location recording state changed", action: null },
        { pattern: /AccuracyLimited changed/i, meaning: "üîã Location accuracy limited (low power/hot device)", action: null },
      ],
      // iOS-specific permission states
      permissions: [
        { pattern: /device_locations=undetermined/i, meaning: "üìç Location permission NOT YET REQUESTED", action: "User hasn't been prompted for location permission yet. They need to open the app and respond to the permission prompt, or go to Settings ‚Üí Hubstaff ‚Üí Location ‚Üí 'Always'." },
        { pattern: /device_locations=denied/i, meaning: "üìç Location permission DENIED", action: "User denied location permission. Go to iOS Settings ‚Üí Privacy & Security ‚Üí Location Services ‚Üí Hubstaff ‚Üí select 'Always'." },
        { pattern: /device_locations=restricted/i, meaning: "üìç Location permission RESTRICTED", action: "Location is restricted by device management (MDM) or parental controls. Contact IT admin to allow location access for Hubstaff." },
        { pattern: /device_locations=authorizedWhenInUse/i, meaning: "üìç Location set to 'While Using' - NOT SUFFICIENT", action: "Location is set to 'While Using App' which won't work for background tracking. User must change to 'Always' in iOS Settings ‚Üí Hubstaff ‚Üí Location." },
        { pattern: /device_locations=authorizedAlways/i, meaning: "üìç Location permission correctly set to 'Always'", action: null },
        { pattern: /status=notDetermined/i, meaning: "üìç iOS location permission not yet determined", action: "User needs to respond to the location permission prompt, or manually enable in Settings ‚Üí Hubstaff ‚Üí Location ‚Üí 'Always'." },
      ]
    };

    function checkLocationPatterns(msg, level) {
      const patterns = LOCATION_PATTERNS[level.toLowerCase()] || [];
      for (const p of patterns) {
        if (p.pattern.test(msg)) return { text: p.meaning, action: p.action };
      }
      for (const lvl of ['errors', 'audit', 'info', 'trace', 'permissions']) {
        for (const p of LOCATION_PATTERNS[lvl] || []) {
          if (p.pattern.test(msg)) return { text: p.meaning, action: p.action };
        }
      }
      return null;
    }

    // === NOISE FILTER PATTERNS ===
    const NOISE_PATTERNS = [
      /WindowsInput\.cpp/,
      /InputExtension\.h/,
      /Heart beat\s*:/i,
      /Response:\s*200\b/,
      /Response:\s*201\b/,
      /Response:\s*204\b/,
      /Check CURL Response/i,
      /Storage\.h.*Read/i,
    ];

    const HELPER_CLIENT_PATTERN = /HelperClient\.cpp/;
    const HELPER_CLIENT_KEEP = /(URL:|APP:|TITLE:)/i;
    const STORAGE_IO_WROTE_PATTERN = /StorageIO.*Wrote/i;
    const STORAGE_IO_KEEP = /(Location|TrackedActivity)/i;

    const SIGNAL_PATTERNS = [
      /\[ERROR\]/i, /\[WARN\]/i, /\[AUDIT\]/i,
      /main_watchdog hit/i, /OS Memory/i, /Helper died/i, /Startup/i,
      /Discard=/i, /\bResume\b/i, /\bIdle\b/i,
      /Server Error/i, /Possible traffic issue/i,
      /Response:\s*4\d{2}/, /Response:\s*5\d{2}/,
      /Uploading Screen/i, /Capture Screen/i, /Wrote ScreenData/i,
      /feed:\s*sites/i, /LocationFeatureState/i, /LocationManager/i,
    ];

    const APP_GRABBER_PATTERN = /ApplicationGrabber/i;
    const APP_GRABBER_KEEP = /(URL:|TITLE:)/i;

    function isSignal(line) {
      for (const p of SIGNAL_PATTERNS) if (p.test(line)) return true;
      if (APP_GRABBER_PATTERN.test(line) && APP_GRABBER_KEEP.test(line)) return true;
      if (HELPER_CLIENT_PATTERN.test(line) && HELPER_CLIENT_KEEP.test(line)) return true;
      return false;
    }

    function isNoise(line) {
      for (const p of NOISE_PATTERNS) if (p.test(line)) return true;
      if (HELPER_CLIENT_PATTERN.test(line) && !HELPER_CLIENT_KEEP.test(line)) return true;
      if (STORAGE_IO_WROTE_PATTERN.test(line) && !STORAGE_IO_KEEP.test(line)) return true;
      return false;
    }

    function filterLogs(lines) {
      return lines.filter(line => {
        if (!line.trim()) return false;
        if (isSignal(line)) return true;
        if (isNoise(line)) return false;
        return true;
      });
    }

    function parseTimestamp(line) {
      const m = line.match(/^(\d{4}-\d{2}-\d{2})\s+(\d{2}:\d{2}:\d{2})/);
      if (!m) return null;
      return new Date(`${m[1]}T${m[2]}`);
    }

    function parseTimezone(line) {
      // Check for explicit TZ Offset line (e.g., "TZ Offset  : 05:30:00" or "TZ Offset  : -05:30:00")
      const tzOffsetMatch = line.match(/TZ Offset\s*:\s*(-?)(\d{2}):(\d{2})/i);
      if (tzOffsetMatch) {
        const sign = tzOffsetMatch[1] === '-' ? '-' : '+';
        return `${sign}${tzOffsetMatch[2]}:${tzOffsetMatch[3]}`;
      }
      
      // Check for timestamp suffix timezone (e.g., "+0530" or "-08:00")
      const m = line.match(/([+-]\d{2}:?\d{2})\s*$/);
      if (m) {
        let tz = m[1];
        if (!tz.includes(':')) tz = tz.slice(0,3) + ':' + tz.slice(3);
        return tz;
      }
      const m2 = line.match(/\s([+-]\d{4})\s/);
      if (m2) {
        const tz = m2[1];
        return tz.slice(0,3) + ':' + tz.slice(3);
      }
      return null;
    }

    function fmtDuration(secs) {
      if (!secs || secs < 0) return '0:00:00';
      secs = Math.floor(secs);
      const h = Math.floor(secs / 3600);
      const m = Math.floor((secs % 3600) / 60);
      const s = secs % 60;
      return `${h}:${pad(m)}:${pad(s)}`;
    }

    function parseLevel(line) {
      if (line.includes('[ERROR]')) return 'ERROR';
      if (line.includes('[WARN]')) return 'WARN';
      if (line.includes('[AUDIT]')) return 'AUDIT';
      if (line.includes('[INFO]')) return 'INFO';
      if (line.includes('[DEBUG]')) return 'DEBUG';
      if (line.includes('[TRACE]')) return 'TRACE';
      return 'UNKNOWN';
    }

    function parseSource(line) {
      const m = line.match(/\]\s+(\w+\.\w+:\d+)/);
      return m ? m[1] : '';
    }

    function parseMessage(line) {
      const m = line.match(/\]\s+\w+\.\w+:\d+\s+(.+)$/);
      return m ? m[1] : line;
    }

    function fmtTime(date) {
      return fmtTimeWithTz(date, false);
    }

    function fmtDate(date) {
      return fmtTimeWithTz(date, true);
    }

    function escapeHtml(str) {
      return str.replace(/&/g,'&amp;').replace(/</g,'&lt;').replace(/>/g,'&gt;');
    }

    // === PLAIN ENGLISH TRANSLATIONS ===
    function translateToPlainEnglish(msg, level, src) {
      const m = msg.toLowerCase();
      
      // Check location-specific patterns first
      const locTranslation = checkLocationPatterns(msg, level);
      if (locTranslation) return { ...locTranslation, severity: level === 'ERROR' ? 'critical' : level === 'WARN' ? 'warning' : 'info' };
      
      // Watchdog / Freezing
      if (m.includes('main_watchdog hit')) 
        return { text: "‚ö†Ô∏è The app froze or became unresponsive", action: "Ask user if app felt slow/frozen. May need to restart the app.", severity: "critical" };
      
      // Helper / Extension
      if (m.includes('helper died') || m.includes('helper crash'))
        return { text: "üîå The browser extension crashed", action: "Ask user to reinstall the browser extension and restart their browser.", severity: "critical" };
      
      // Memory
      if (m.includes('os memory') || m.includes('low memory'))
        return { text: "üíæ Computer is running low on memory (RAM)", action: "User may have too many apps open. Suggest closing unused programs.", severity: "warning" };
      
      // Screenshots
      if (m.includes('uploading screen'))
        return { text: "üì∏ Screenshot was captured and is uploading", action: null, severity: "info" };
      if (m.includes('capture screen'))
        return { text: "üì∏ Taking a screenshot", action: null, severity: "info" };
      if (m.includes('screenshot') && (m.includes('fail') || m.includes('error')))
        return { text: "üì∏ Screenshot failed to capture or upload", action: "Check user's internet connection and screen capture permissions.", severity: "warning" };
      
      // Network errors
      if (m.includes('response: 401') || m.includes('response: 403'))
        return { text: "üîê Authentication failed - user may be logged out", action: "Ask user to log out and log back into Hubstaff.", severity: "critical" };
      if (m.includes('response: 404'))
        return { text: "‚ùì Server couldn't find the requested data", action: "The project or task may have been deleted. Check if it still exists.", severity: "warning" };
      if (m.includes('response: 500') || m.includes('response: 502') || m.includes('response: 503'))
        return { text: "üåê Hubstaff server error occurred", action: "This is a server-side issue. Check status.hubstaff.com for outages.", severity: "critical" };
      if (m.includes('server error'))
        return { text: "üåê Couldn't connect to Hubstaff servers", action: "Check user's internet. If working, check status.hubstaff.com.", severity: "warning" };
      if (m.includes('traffic issue') || m.includes('network error'))
        return { text: "üåê Network connection problem", action: "User may have unstable internet. Ask about WiFi/connection quality.", severity: "warning" };
      if (m.includes('timeout'))
        return { text: "‚è±Ô∏è Request timed out - server took too long", action: "Usually temporary. If persistent, check internet speed.", severity: "warning" };
      
      // Time tracking
      if (m.includes('discard=1') || m.includes('discard=true')) {
        if (m.includes('locked')) return { text: "üîí Time rejected - timesheet is locked/approved", action: "Admin has locked this timesheet. Time cannot be added.", severity: "critical" };
        if (m.includes('future')) return { text: "‚è∞ Time rejected - computer clock is wrong", action: "User's computer clock is set to the future. Fix system time.", severity: "critical" };
        if (m.includes('duplicate')) return { text: "üìã Time rejected - already recorded", action: "This time was already uploaded. No action needed.", severity: "info" };
        return { text: "‚ùå Tracked time was rejected by the server", action: "Check the specific reason. May need manual time entry.", severity: "critical" };
      }
      if (m.includes('resume_ignored'))
        return { text: "‚è≠Ô∏è Resume time was auto-discarded by policy", action: "User should open app periodically to confirm timer is intentional.", severity: "warning" };
      if (m.includes('resume_cancelled'))
        return { text: "‚ùå User chose not to keep resumed time", action: null, severity: "info" };
      if (m.includes('resume_detected'))
        return { text: "üîÑ Timer was left running when app closed - recovering time", action: null, severity: "info" };
      if (m.includes('start_ignored'))
        return { text: "üö´ Timer start was blocked by a policy", action: "Check organization policies - may be location restriction, limit, or schedule.", severity: "warning" };
      if (m.includes('tracking_stopped'))
        return { text: "‚èπÔ∏è Tracking was stopped by the system", action: "Check logs for specific reason (limit reached, policy, error).", severity: "warning" };
      if (m.includes('resume') && !m.includes('resume_ignored'))
        return { text: "‚ñ∂Ô∏è Tracking resumed after interruption", action: null, severity: "info" };
      if (m.includes('idle') && m.includes('wake'))
        return { text: "üí§ User returned from being idle", action: null, severity: "info" };
      if (m.includes('idle') && !m.includes('wake'))
        return { text: "üí§ User went idle (no activity detected)", action: null, severity: "info" };
      
      // Startup
      if (m.includes('startup') && m.includes('clean'))
        return { text: "‚úÖ App started normally", action: null, severity: "success" };
      if (m.includes('startup') && m.includes('unclean'))
        return { text: "‚ö†Ô∏è App restarted after a crash", action: "Check if time was recovered. Look for RESUME events after this.", severity: "warning" };
      
      // Location / Job Sites
      if (m.includes('locationmanager') || m.includes('locationfeature'))
        return { text: "üìç Location/Job Site feature activity", action: null, severity: "info" };
      if (m.includes('geofence') && m.includes('enter'))
        return { text: "üìç User entered a Job Site location", action: null, severity: "info" };
      if (m.includes('geofence') && m.includes('exit'))
        return { text: "üìç User left a Job Site location", action: "If tracking stopped unexpectedly, this may be why.", severity: "info" };
      if (m.includes('location') && m.includes('denied'))
        return { text: "üìç Location permission was denied", action: "User needs to enable location permissions for Job Sites to work.", severity: "warning" };
      
      // URLs and Apps
      if (m.includes('url:') && m.includes('title:'))
        return { text: "üñ•Ô∏è Recorded active window/website", action: null, severity: "info" };
      if (m.includes('applicationgrabber'))
        return { text: "üñ•Ô∏è Detecting active application", action: null, severity: "info" };
      
      // Generic errors/warnings
      if (level === 'ERROR')
        return { text: "‚ùå An error occurred in the app", action: "Review the technical details below for more context.", severity: "critical" };
      if (level === 'WARN')
        return { text: "‚ö†Ô∏è Something unexpected happened", action: "Usually not critical, but worth noting if issues persist.", severity: "warning" };
      
      return null;
    }

    // === DEVICE STATUS DASHBOARD GENERATION ===
    function generateDeviceDashboard(data) {
      // Extract user info
      const userPropsLine = allLines.find(line => line.includes('user_id=') && line.includes('user_name='));
      let userId = null, userName = null, userEmail = null, orgName = null, orgId = null;
      
      if (userPropsLine) {
        const userIdMatch = userPropsLine.match(/user_id=(\d+)/);
        const userNameMatch = userPropsLine.match(/user_name=([^,}]+)/);
        const userEmailMatch = userPropsLine.match(/user_email=([^,}]+)/);
        const orgNameMatch = userPropsLine.match(/organization_name=([^,}]+)/);
        const orgIdMatch = userPropsLine.match(/organization_id=(\d+)/);
        
        if (userIdMatch) userId = userIdMatch[1];
        if (userNameMatch) userName = userNameMatch[1];
        if (userEmailMatch) userEmail = userEmailMatch[1];
        if (orgNameMatch) orgName = orgNameMatch[1];
        if (orgIdMatch) orgId = orgIdMatch[1];
      }
      
      // Extract device info
      const deviceLine = allLines.find(line => line.includes('device manufacturer'));
      let manufacturer = null, model = null, osVersion = null;
      
      if (deviceLine) {
        const mfgMatch = deviceLine.match(/manufacturer\s*:\s*(\w+)/i);
        const modelMatch = deviceLine.match(/model:\s*([\w-]+)/i);
        const osMatch = deviceLine.match(/OS:\s*(\d+)/i);
        if (mfgMatch) manufacturer = mfgMatch[1];
        if (modelMatch) model = modelMatch[1];
        if (osMatch) osVersion = osMatch[1];
      }
      
      // Extract location state
      const locationStateLine = allLines.find(line => line.includes('locationState is'));
      let servicesEnabled = false, permissionsEnabled = false, accuracyEnabled = false, locationEnabled = false;
      
      if (locationStateLine) {
        servicesEnabled = locationStateLine.includes('SERVICES_ENABLED');
        permissionsEnabled = locationStateLine.includes('PERMISSIONS_ENABLED');
        accuracyEnabled = locationStateLine.includes('ACCURACY_ENABLED');
        locationEnabled = locationStateLine.includes('locationEnabled = true');
      }
      
      // Extract primary device status
      const primaryLine = allLines.find(line => line.includes('primary:'));
      let isPrimary = null;
      if (primaryLine) {
        isPrimary = primaryLine.includes('primary: true');
      }
      
      // Extract permission states
      const permStateLine = allLines.find(line => line.includes('permission state is State'));
      let notificationPerm = null, foregroundLocPerm = null, backgroundLocPerm = null, motionPerm = null;
      
      if (permStateLine) {
        notificationPerm = permStateLine.includes('NOTIFICATION, enabled=true');
        foregroundLocPerm = permStateLine.includes('FOREGROUND_LOCATION, enabled=true');
        backgroundLocPerm = permStateLine.includes('BACKGROUND_LOCATION, enabled=true');
        motionPerm = permStateLine.includes('USER_MOTION, enabled=true');
      }
      
      // Extract device state
      const deviceStateLine = allLines.find(line => line.includes('isIgnoringBatteryOptimization'));
      let batteryOptDisabled = null, powerSaveMode = null, deviceIdle = null, wifiEnabled = null, isInteractive = null;
      
      if (deviceStateLine) {
        batteryOptDisabled = deviceStateLine.includes('isIgnoringBatteryOptimization: =true');
        powerSaveMode = deviceStateLine.includes('isPowerSaveMode: =true');
        deviceIdle = deviceStateLine.includes('isDeviceIdle: =true');
        wifiEnabled = deviceStateLine.includes('isWifiEnabled: =true');
        isInteractive = deviceStateLine.includes('isInteractive: =true');
      }
      
      // Count issues
      const dnsErrors = allLines.filter(line => line.includes('Could not resolve host') || line.includes('UnknownHostException')).length;
      const uncleanStartups = allLines.filter(line => line.includes('STARTUP_UNCLEAN')).length;
      const jobSiteBlocks = allLines.filter(line => line.includes('TRACKING_NOT_STARTED') || line.includes('requires being at a job site')).length;
      
      // Build status object
      return {
        user: { id: userId, name: userName, email: userEmail },
        org: { id: orgId, name: orgName },
        device: { manufacturer, model, osVersion },
        location: {
          isPrimary,
          servicesEnabled,
          permissionsEnabled,
          accuracyEnabled,
          locationEnabled
        },
        permissions: {
          notification: notificationPerm,
          foregroundLocation: foregroundLocPerm,
          backgroundLocation: backgroundLocPerm,
          motion: motionPerm
        },
        deviceState: {
          batteryOptDisabled,
          powerSaveMode,
          deviceIdle,
          wifiEnabled,
          isInteractive
        },
        issues: {
          dnsErrors,
          uncleanStartups,
          jobSiteBlocks
        }
      };
    }

    function renderDeviceDashboard(status) {
      if (!status.user.id && !status.device.manufacturer) {
        $('deviceDashboard').style.display = 'none';
        return;
      }
      
      const statusIcon = (value, trueIsGood = true) => {
        if (value === null) return '<span class="status-icon">‚ùì</span>';
        const isGood = trueIsGood ? value : !value;
        return isGood ? '<span class="status-icon success">‚úÖ</span>' : '<span class="status-icon error">‚ùå</span>';
      };
      
      const warnIcon = (value, trueIsGood = true) => {
        if (value === null) return '<span class="status-icon">‚ùì</span>';
        const isGood = trueIsGood ? value : !value;
        return isGood ? '<span class="status-icon success">‚úÖ</span>' : '<span class="status-icon warning">‚ö†Ô∏è</span>';
      };
      
      let html = `
        <div class="device-dashboard">
          <div class="dashboard-header">
            <div class="dashboard-user-info">
              <h3>üì± Device & Location Status</h3>
              ${status.user.name ? `<p><strong>${status.user.name}</strong> (ID: ${status.user.id || 'Unknown'})</p>` : ''}
              ${status.org.name ? `<p>üè¢ ${status.org.name}</p>` : ''}
            </div>
            <div class="dashboard-device-info">
              ${status.device.manufacturer ? `<div class="device-model">${status.device.manufacturer} ${status.device.model || ''}</div>` : ''}
              ${status.device.osVersion ? `<div>Android API ${status.device.osVersion}</div>` : ''}
            </div>
          </div>
          
          <div class="dashboard-grid">
            <div class="dashboard-card">
              <h4>üìç Location Status</h4>
              <div class="status-row">${statusIcon(status.location.isPrimary)}<span class="status-label">Primary Device</span></div>
              <div class="status-row">${statusIcon(status.location.locationEnabled)}<span class="status-label">Location Enabled</span></div>
              <div class="status-row">${statusIcon(status.location.servicesEnabled)}<span class="status-label">Services Enabled</span></div>
              <div class="status-row">${statusIcon(status.location.permissionsEnabled)}<span class="status-label">Permissions OK</span></div>
              <div class="status-row">${statusIcon(status.location.accuracyEnabled)}<span class="status-label">Accuracy Enabled</span></div>
            </div>
            
            <div class="dashboard-card">
              <h4>üîê Permissions</h4>
              <div class="status-row">${statusIcon(status.permissions.foregroundLocation)}<span class="status-label">Foreground Location</span></div>
              <div class="status-row">${statusIcon(status.permissions.backgroundLocation)}<span class="status-label">Background Location</span></div>
              <div class="status-row">${statusIcon(status.permissions.notification)}<span class="status-label">Notifications</span></div>
              <div class="status-row">${statusIcon(status.permissions.motion)}<span class="status-label">Motion/Activity</span></div>
            </div>
            
            <div class="dashboard-card">
              <h4>üîã Device State</h4>
              <div class="status-row">${warnIcon(status.deviceState.batteryOptDisabled)}<span class="status-label">Battery Opt Disabled</span></div>
              <div class="status-row">${statusIcon(status.deviceState.powerSaveMode, false)}<span class="status-label">Power Save Mode</span><span class="status-value">${status.deviceState.powerSaveMode ? 'ON' : 'OFF'}</span></div>
              <div class="status-row">${statusIcon(status.deviceState.deviceIdle, false)}<span class="status-label">Device Idle (Doze)</span><span class="status-value">${status.deviceState.deviceIdle ? 'YES' : 'NO'}</span></div>
              <div class="status-row">${statusIcon(status.deviceState.wifiEnabled)}<span class="status-label">WiFi</span><span class="status-value">${status.deviceState.wifiEnabled ? 'ON' : 'OFF'}</span></div>
            </div>
            
            <div class="dashboard-card">
              <h4>‚ö†Ô∏è Issues Detected</h4>
              <div class="status-row"><span class="status-icon ${status.issues.dnsErrors > 0 ? 'error' : 'success'}">${status.issues.dnsErrors > 0 ? '‚ùå' : '‚úÖ'}</span><span class="status-label">Network/DNS Errors</span><span class="status-value">${status.issues.dnsErrors}</span></div>
              <div class="status-row"><span class="status-icon ${status.issues.uncleanStartups > 5 ? 'error' : status.issues.uncleanStartups > 0 ? 'warning' : 'success'}">${status.issues.uncleanStartups > 5 ? '‚ùå' : status.issues.uncleanStartups > 0 ? '‚ö†Ô∏è' : '‚úÖ'}</span><span class="status-label">App Crashes/Kills</span><span class="status-value">${status.issues.uncleanStartups}</span></div>
              <div class="status-row"><span class="status-icon ${status.issues.jobSiteBlocks > 0 ? 'error' : 'success'}">${status.issues.jobSiteBlocks > 0 ? '‚ùå' : '‚úÖ'}</span><span class="status-label">Job Site Blocks</span><span class="status-value">${status.issues.jobSiteBlocks}</span></div>
            </div>
          </div>
        </div>
      `;
      
      $('deviceDashboard').innerHTML = html;
      $('deviceDashboard').style.display = 'block';
    }

    // === VISIT HISTORY RENDERING ===
    function renderVisitHistory(data) {
      const container = $('visitHistorySection');
      if (!container) return;
      
      if (!data.geofenceEvents || data.geofenceEvents.length === 0) {
        container.innerHTML = '';
        return;
      }
      
      const uniqueSites = [...new Map(data.jobSites.map(s => [s.id, s])).values()];
      
      const visits = data.geofenceEvents.map(evt => {
        const nearestSite = uniqueSites.length > 0 ? findNearestSite(evt.lat, evt.lng, uniqueSites) : null;
        const isInside = nearestSite ? (nearestSite.distance <= nearestSite.radius) : false;
        
        let accuracyClass = 'good';
        if (evt.accuracy > 50) accuracyClass = 'poor';
        else if (evt.accuracy > 20) accuracyClass = 'fair';
        
        return { ...evt, nearestSite, isInside, accuracyClass };
      });
      
      const enterCount = visits.filter(v => v.type === 'ENTER').length;
      const exitCount = visits.filter(v => v.type === 'EXIT').length;
      const neverInside = visits.filter(v => v.type === 'ENTER' && !v.isInside).length;
      
      let html = `
        <div class="visit-history-box">
          <h4>üïê Job Site Visit History <span style="font-weight:normal; font-size:11px; color:var(--muted);">(Geofence events with map links)</span></h4>
          <div class="visit-stats">
            <div class="stat"><span class="stat-value">${enterCount}</span><span class="stat-label">Boundary Entries</span></div>
            <div class="stat"><span class="stat-value">${exitCount}</span><span class="stat-label">Boundary Exits</span></div>
            ${neverInside > 0 ? `<div class="stat"><span class="stat-value radius-small">‚ö†Ô∏è ${neverInside}</span><span class="stat-label">Entries outside site radius</span></div>` : ''}
          </div>
          
          <div style="max-height:350px; overflow-y:auto;">
            ${visits.slice(0, 30).map(v => `
              <div class="visit-entry ${v.type.toLowerCase()}">
                <span class="visit-icon">${v.type === 'ENTER' ? 'üìç' : 'üö∂'}</span>
                <div class="visit-details">
                  <div class="visit-time">${v.type === 'ENTER' ? 'Entered geofence boundary' : 'Exited geofence boundary'} ‚Äî ${fmtDate(v.ts)}</div>
                  <div class="visit-coords">
                    <span>User at: <strong>${v.lat.toFixed(6)}, ${v.lng.toFixed(6)}</strong></span>
                    ${generateMapLink(v.lat, v.lng, 'View User Location')}
                  </div>
                  
                  ${v.nearestSite ? `
                    <div class="visit-site-info">
                      <div class="visit-site-name">üìå Nearest configured site: ${escapeHtml(v.nearestSite.name)}</div>
                      <div class="visit-coords" style="margin-top:4px;">
                        <span>Site at: ${v.nearestSite.lat.toFixed(6)}, ${v.nearestSite.lng.toFixed(6)}</span>
                        ${generateMapLink(v.nearestSite.lat, v.nearestSite.lng, 'View Site Location')}
                      </div>
                      <div class="visit-distance ${v.isInside ? 'inside' : 'outside'}">
                        ${v.isInside 
                          ? `‚úÖ Within radius: ${v.nearestSite.distance}m away (site radius: ${v.nearestSite.radius}m)`
                          : `‚ö†Ô∏è OUTSIDE radius: ${v.nearestSite.distance}m away (site radius: ${v.nearestSite.radius}m) ‚Äî ${v.nearestSite.distance - v.nearestSite.radius}m outside boundary`
                        }
                      </div>
                      <div class="location-comparison">
                        <div class="compare-row">
                          <span class="compare-label">User ‚Üí Site distance:</span>
                          <span class="compare-value">${v.nearestSite.distance.toLocaleString()}m</span>
                        </div>
                        <div class="compare-row">
                          <span class="compare-label">Site radius:</span>
                          <span class="compare-value">${v.nearestSite.radius}m</span>
                        </div>
                        <div class="compare-row">
                          <span class="compare-label">GPS accuracy:</span>
                          <span class="compare-value">¬±${v.accuracy ? Math.round(v.accuracy) : '?'}m</span>
                        </div>
                      </div>
                    </div>
                  ` : `
                    <div class="visit-site-info">
                      <div style="color:var(--warn);">‚ö†Ô∏è No job sites configured in logs to compare against</div>
                    </div>
                  `}
                </div>
                <span class="visit-accuracy ${v.accuracyClass}">¬±${v.accuracy ? Math.round(v.accuracy) : '?'}m</span>
              </div>
            `).join('')}
            ${visits.length > 30 ? `<div style="text-align:center; padding:10px; color:var(--muted); font-size:11px;">... and ${visits.length - 30} more events</div>` : ''}
          </div>
        </div>
      `;
      
      container.innerHTML = html;
    }

    // === ROOT CAUSE CONCLUSION GENERATION ===
    function generateRootCauseConclusion(status, data) {
      const dominated = []; // Issues sorted by severity/likelihood
      const evidence = [];
      const actionSteps = [];
      
      // === ANALYZE AND RANK ISSUES ===
      
      // 1. Job Site Blocks (user's direct complaint usually)
      if (status.issues.jobSiteBlocks > 0) {
        // Check for small radius sites
        const geofenceLines = allLines.filter(l => l.includes('creating geofence') && !l.includes('id=-'));
        const radiusMatches = geofenceLines.map(l => {
          const m = l.match(/,\s*(\d+)\)$/);
          return m ? parseInt(m[1]) : null;
        }).filter(r => r !== null);
        const smallRadiusCount = radiusMatches.filter(r => r <= 50).length;
        const totalSites = new Set(geofenceLines.map(l => {
          const m = l.match(/id=(\d+)/);
          return m ? m[1] : null;
        })).size;
        
        let radiusNote = '';
        if (smallRadiusCount > totalSites * 0.5) {
          radiusNote = ` <strong>Note:</strong> ${smallRadiusCount} of ${totalSites} sites have a 50m radius, which may be too small for reliable detection indoors.`;
        }
        
        dominated.push({
          severity: 10,
          cause: "the user is <strong>not being detected at a job site</strong>",
          detail: `The timer was blocked ${status.issues.jobSiteBlocks} time(s) because the system determined the user wasn't at a configured job site.${radiusNote}`
        });
        evidence.push(`Timer blocked ${status.issues.jobSiteBlocks}x with "requires being at a job site" error`);
        if (smallRadiusCount > 0) {
          evidence.push(`${smallRadiusCount} job sites have 50m radius (may be too small)`);
          actionSteps.push("Consider increasing job site radius to 100-150m for better indoor detection");
        }
      }
      
      // 2. Network/DNS Issues (prevents everything)
      if (status.issues.dnsErrors > 10) {
        dominated.push({
          severity: 9,
          cause: "<strong>no internet connection</strong> during key moments",
          detail: `Found ${status.issues.dnsErrors} DNS/network failures. Without internet, the app cannot verify job site status or start tracking, even if GPS shows the correct location.`
        });
        evidence.push(`${status.issues.dnsErrors} DNS resolution failures (Could not resolve host)`);
        actionSteps.push("Check if WiFi/mobile data was working during the issue");
        actionSteps.push("Try switching between WiFi and cellular data");
        actionSteps.push("Restart the device to reset network connections");
      }
      
      // 3. Not Primary Device
      if (status.location.isPrimary === false) {
        dominated.push({
          severity: 8,
          cause: "this device is <strong>not set as the primary device</strong>",
          detail: "Only the primary device can record locations and trigger job site automations. The user may have logged in on another device."
        });
        evidence.push("Device reports primary: false");
        actionSteps.push("User should tap 'Make Primary' banner on the Timer screen");
        actionSteps.push("Or check Admin ‚Üí User page to see which device is primary");
      }
      
      // 4. Battery Optimization Killing App
      if (status.deviceState.batteryOptDisabled === false && status.issues.uncleanStartups > 5) {
        dominated.push({
          severity: 8,
          cause: "<strong>Android is killing the app</strong> to save battery",
          detail: `Battery optimization is ON and the app crashed/was killed ${status.issues.uncleanStartups} times. Android is aggressively closing Hubstaff in the background.`
        });
        evidence.push(`Battery optimization is ENABLED (isIgnoringBatteryOptimization: false)`);
        evidence.push(`${status.issues.uncleanStartups} unclean startups (app was killed)`);
        actionSteps.push("Disable battery optimization: Settings ‚Üí Apps ‚Üí Hubstaff ‚Üí Battery ‚Üí Unrestricted");
        if (status.device.manufacturer?.toLowerCase() === 'samsung') {
          actionSteps.push("Samsung: Also remove from 'Sleeping apps' and 'Deep sleeping apps' lists");
        }
      } else if (status.issues.uncleanStartups > 10) {
        dominated.push({
          severity: 7,
          cause: "the <strong>app is repeatedly crashing or being killed</strong>",
          detail: `Found ${status.issues.uncleanStartups} unclean startups. The app is not staying running in the background.`
        });
        evidence.push(`${status.issues.uncleanStartups} STARTUP_UNCLEAN events`);
        actionSteps.push("Check battery optimization settings");
        actionSteps.push("Check if user is manually force-closing the app");
      }
      
      // 5. Background Location Permission
      if (status.permissions.backgroundLocation === false) {
        dominated.push({
          severity: 8,
          cause: "<strong>background location permission is not granted</strong>",
          detail: "The app can only access location while on screen. Job site detection requires 'Allow all the time' permission."
        });
        evidence.push("BACKGROUND_LOCATION permission is disabled");
        actionSteps.push("Settings ‚Üí Apps ‚Üí Hubstaff ‚Üí Permissions ‚Üí Location ‚Üí 'Allow all the time'");
      }
      
      // 6. Location Services Disabled
      if (status.location.servicesEnabled === false) {
        dominated.push({
          severity: 9,
          cause: "<strong>location services are disabled</strong> on the device",
          detail: "The device's location services are turned off. GPS cannot work at all."
        });
        evidence.push("SERVICES_ENABLED is false in locationState");
        actionSteps.push("Enable Location Services in device Settings");
      }
      
      // 7. Battery optimization without crashes (potential future issue)
      if (status.deviceState.batteryOptDisabled === false && status.issues.uncleanStartups <= 5) {
        dominated.push({
          severity: 4,
          cause: "<strong>battery optimization is enabled</strong> (potential issue)",
          detail: "Battery optimization is ON. While not causing crashes yet, this may cause issues with background tracking."
        });
        evidence.push("isIgnoringBatteryOptimization: false");
        actionSteps.push("Recommend disabling battery optimization as a preventive measure");
      }
      
      // 8. Job Site / Geofence Analysis
      if (data.geofenceEvents && data.geofenceEvents.length > 0) {
        const uniqueSites = [...new Map(data.jobSites.map(s => [s.id, s])).values()];
        
        // Analyze each geofence event
        let outsideRadiusCount = 0;
        let poorAccuracyCount = 0;
        let enterEvents = 0;
        let exitEvents = 0;
        const outsideDetails = [];
        
        data.geofenceEvents.forEach(evt => {
          if (evt.type === 'ENTER') enterEvents++;
          if (evt.type === 'EXIT') exitEvents++;
          
          if (evt.accuracy && evt.accuracy > 50) poorAccuracyCount++;
          
          if (uniqueSites.length > 0) {
            const nearest = findNearestSite(evt.lat, evt.lng, uniqueSites);
            if (nearest && nearest.distance > nearest.radius) {
              outsideRadiusCount++;
              const outsideBy = nearest.distance - nearest.radius;
              outsideDetails.push(`${evt.type} event ${nearest.distance}m from "${nearest.name}" (radius: ${nearest.radius}m, ${outsideBy}m outside)`);
            }
          }
        });
        
        // Add findings based on analysis
        if (outsideRadiusCount > 0) {
          dominated.push({
            severity: 7,
            cause: `<strong>user was outside job site radius</strong> during ${outsideRadiusCount} geofence event${outsideRadiusCount > 1 ? 's' : ''}`,
            detail: `The user triggered geofence boundaries but was actually outside the configured site radius. This can happen when: 1) Job site radius is too small, 2) GPS accuracy is poor, 3) The job site pin is in the wrong location.`
          });
          evidence.push(`${outsideRadiusCount} of ${data.geofenceEvents.length} geofence events were outside the nearest site's radius`);
          outsideDetails.slice(0, 3).forEach(d => evidence.push(d));
          actionSteps.push("Check the Locations section for map links to compare user position vs site location");
          actionSteps.push("Consider increasing job site radius to 100-150m");
        }
        
        if (poorAccuracyCount > data.geofenceEvents.length * 0.5) {
          dominated.push({
            severity: 5,
            cause: "<strong>GPS accuracy was poor</strong> during location events",
            detail: `${poorAccuracyCount} of ${data.geofenceEvents.length} location events had accuracy worse than 50m. Poor GPS signal makes job site detection unreliable.`
          });
          evidence.push(`${poorAccuracyCount} events with GPS accuracy >50m`);
          actionSteps.push("User should try going outdoors with clear sky view for better GPS");
          actionSteps.push("Check if device has 'High Accuracy' location mode enabled");
        }
        
        // Add summary even if no issues
        if (outsideRadiusCount === 0 && enterEvents > 0) {
          evidence.push(`‚úì ${enterEvents} site entry event${enterEvents > 1 ? 's' : ''} detected, all within configured radius`);
        }
      }
      
      // 9. Job Sites Configuration Issues
      if (data.jobSites && data.jobSites.length > 0) {
        const uniqueSites = [...new Map(data.jobSites.map(s => [s.id, s])).values()];
        const smallRadiusSites = uniqueSites.filter(s => s.radius <= 50);
        
        if (smallRadiusSites.length > uniqueSites.length * 0.5) {
          dominated.push({
            severity: 5,
            cause: `<strong>${smallRadiusSites.length} of ${uniqueSites.length} job sites have small radius</strong> (‚â§50m)`,
            detail: "A 50m radius is often too small for reliable detection, especially indoors where GPS accuracy is reduced. This frequently causes 'not at job site' errors even when the user is physically present."
          });
          evidence.push(`${smallRadiusSites.length} sites configured with ‚â§50m radius`);
          actionSteps.push("Increase job site radius to 100-150m for more reliable detection");
        }
      }
      
      // 10. No geofence events but job site blocks
      if (status.issues.jobSiteBlocks > 0 && (!data.geofenceEvents || data.geofenceEvents.length === 0)) {
        evidence.push("‚ö†Ô∏è Timer was blocked for job site reasons but no geofence events found in logs");
        actionSteps.push("Enable 'Show DEBUG level' to see detailed location data");
        actionSteps.push("Check if location permissions are set to 'Always' (not 'While Using')");
      }
      
      // Sort by severity
      dominated.sort((a, b) => b.severity - a.severity);
      
      // === BUILD CONCLUSION ===
      if (dominated.length === 0) {
        // No issues found
        return {
          isSuccess: true,
          html: `
            <div class="root-cause-box success">
              <h3>‚úÖ No Major Issues Detected</h3>
              <div class="conclusion">
                Based on the log analysis, <strong>all device settings and permissions appear to be correctly configured</strong>. 
                The app should be functioning normally for location tracking and job site detection.
              </div>
              <div class="evidence">
                <h4>‚úì Verified Working:</h4>
                <ul>
                  ${status.location.isPrimary !== false ? '<li>Device is set as primary</li>' : ''}
                  ${status.location.servicesEnabled ? '<li>Location services are enabled</li>' : ''}
                  ${status.permissions.backgroundLocation !== false ? '<li>Background location permission granted</li>' : ''}
                  ${status.deviceState.batteryOptDisabled !== false ? '<li>Battery optimization is disabled</li>' : ''}
                  ${status.issues.dnsErrors === 0 ? '<li>No network connectivity issues</li>' : ''}
                </ul>
              </div>
              <div class="action-steps">
                <h4>üí° If the user is still experiencing issues:</h4>
                <ol>
                  <li>Ask for more specific details about what's happening</li>
                  <li>Check if the job site radius is large enough (recommend 100-150m)</li>
                  <li>Verify the job site pin is in the correct location on the map</li>
                  <li>Check GPS signal quality - try going outdoors with clear sky</li>
                </ol>
              </div>
            </div>
          `
        };
      }
      
      // Build HTML for issues found
      const topCause = dominated[0];
      const secondaryCauses = dominated.slice(1, 3).filter(d => d.severity >= 5);
      
      let conclusionText = `Based on the log analysis, the issue is most likely caused by ${topCause.cause}.`;
      if (secondaryCauses.length > 0) {
        conclusionText += ` Contributing factors may include: ${secondaryCauses.map(d => d.cause).join(', ')}.`;
      }
      
      // Add specific context for job site + network combo (very common)
      if (status.issues.jobSiteBlocks > 0 && status.issues.dnsErrors > 5) {
        conclusionText += `<br><br><strong>Key insight:</strong> The user may have been physically at the job site, but the app couldn't verify this because there was no internet connection. Even with perfect GPS, the app needs network access to start tracking.`;
      }
      
      return {
        isSuccess: false,
        html: `
          <div class="root-cause-box">
            <h3>üîç Root Cause Analysis</h3>
            <div class="conclusion">${conclusionText}</div>
            <div class="evidence">
              <h4>üìã Evidence from logs:</h4>
              <ul>
                ${evidence.map(e => `<li>${e}</li>`).join('')}
              </ul>
            </div>
            ${actionSteps.length > 0 ? `
            <div class="action-steps">
              <h4>üí° Recommended Actions:</h4>
              <ol>
                ${actionSteps.map(a => `<li>${a}</li>`).join('')}
              </ol>
            </div>
            ` : ''}
          </div>
        `
      };
    }

    function generateSummary(data) {
      const findings = [];
      
      // === TRACKING SUMMARY ===
      const totalTrackedSecs = data.sessions.reduce((sum, s) => sum + (s.duration || 0), 0);
      const logDurationSecs = (data.endTime - data.startTime) / 1000;
      
      if (data.sessions.length > 0) {
        const crashedSessions = data.sessions.filter(s => s.stopReason === 'CRASHED' || s.stopReason === 'LOG_END');
        const idleStops = data.sessions.filter(s => s.stopReason === 'IDLE');
        const resumedStarts = data.sessions.filter(s => s.startReason === 'RESUMED');
        const userStops = data.sessions.filter(s => s.stopReason === 'USER');
        
        let sessionDesc = `Found ${data.sessions.length} tracking session${data.sessions.length > 1 ? 's' : ''} totaling <strong>${fmtDuration(totalTrackedSecs)}</strong>.`;
        if (resumedStarts.length > 0) sessionDesc += ` ${resumedStarts.length} session(s) were recovered after a crash.`;
        if (idleStops.length > 0) sessionDesc += ` ${idleStops.length} stopped due to idle timeout.`;
        
        findings.push({
          severity: crashedSessions.length > 0 ? 'warning' : 'info',
          icon: '‚è±Ô∏è',
          title: `Tracked Time: ${fmtDuration(totalTrackedSecs)}`,
          description: sessionDesc,
          action: crashedSessions.length > 0 ? 'Some sessions may have ended unexpectedly. Check the Sessions table below for details.' : null,
          techDetail: null
        });
        
        // === LOG DURATION VS TRACKED TIME COMPARISON ===
        if (logDurationSecs > 600 && totalTrackedSecs < logDurationSecs * 0.1) {
          // Log covers significant time but very little was tracked
          findings.push({
            severity: 'info',
            icon: 'üìä',
            title: `Log Duration: ${fmtDuration(logDurationSecs)} vs Tracked: ${fmtDuration(totalTrackedSecs)}`,
            description: `The log file spans <strong>${fmtDuration(logDurationSecs)}</strong>, but only <strong>${fmtDuration(totalTrackedSecs)}</strong> was actually tracked. This is normal - the app continues logging background activity (app focus, URL detection, system monitoring) even when the timer is not running. <strong>Only time between START and STOP events counts as tracked time.</strong>`,
            action: 'The difference does NOT mean time was lost. Background logs help with diagnostics but do not represent billable time.',

          });
        }
        
        // === USER STOP EXPLANATION ===
        if (userStops.length > 0) {
          const shortSessions = userStops.filter(s => s.duration < 30);
          if (shortSessions.length > 0) {
            findings.push({
              severity: 'info',
              icon: 'üõë',
              title: `${shortSessions.length} Very Short Session${shortSessions.length > 1 ? 's' : ''} (Stopped by USER)`,
              description: `Found ${shortSessions.length} session${shortSessions.length > 1 ? 's' : ''} under 30 seconds that ended with stop reason "USER". <strong>What "USER" means:</strong> The stop was logged as a normal user-initiated stop. If the app had crashed or auto-stopped due to errors, we would see different markers (CRASHED, ERROR, CONFIG, or missing stop events).`,
              action: 'If the user disputes stopping manually, this could indicate: accidental click, mouse/trackpad issue, or another person/process interacting with the app. Network errors, CPU usage, or timezone issues do NOT cause USER stop events.',
              techDetail: shortSessions.map(s => `${fmtTime(s.start)} ‚Üí ${fmtTime(s.stop)} (${Math.round(s.duration)}s)`).join('\n')
            });
          }
        }
        
        // === CRASH INDICATOR CHECK ===
        const hasCrashMarkers = data.errors.some(e => 
          e.msg.toLowerCase().includes('crash') || 
          e.msg.toLowerCase().includes('watchdog') ||
          e.msg.toLowerCase().includes('unclean') ||
          e.msg.toLowerCase().includes('resume_detected')
        );
        const hasResumeEvents = data.tracking.some(e => 
          e.msg.toLowerCase().includes('resume_detected') || 
          e.msg.toLowerCase().includes('resumed')
        );
        
        if (!hasCrashMarkers && !hasResumeEvents && crashedSessions.length === 0) {
          findings.push({
            severity: 'success',
            icon: '‚úÖ',
            title: 'No Crash Indicators Found',
            description: 'The logs show no signs of app crashes, force-quits, or unexpected terminations. All sessions have proper START and STOP events. If the app had crashed, we would expect to see: STARTUP_UNCLEAN, RESUME_DETECTED, watchdog hits, or missing STOP events.',
            action: null,

          });
        }
      } else {
        // No sessions found
        findings.push({
          severity: 'warning',
          icon: '‚è±Ô∏è',
          title: 'No Tracking Sessions Found',
          description: `The log spans <strong>${fmtDuration(logDurationSecs)}</strong> but no START_TRACKING/STOP_TRACKING pairs were detected. This could mean: the timer was never started during this period, or the log file doesn't contain the tracking events.`,
          action: 'Check if this is the correct log file for the time period in question.',
          techDetail: null
        });
      }
      
      // === IDLE SUMMARY ===
      if (data.idleKeptSecs > 0 || data.idleDiscardedSecs > 0) {
        const totalIdle = data.idleKeptSecs + data.idleDiscardedSecs;
        findings.push({
          severity: 'info',
          icon: 'üí§',
          title: `Idle Time: ${fmtDuration(totalIdle)}`,
          description: `User went idle ${data.idleDecisions.length} time(s). Kept ${fmtDuration(data.idleKeptSecs)}, discarded ${fmtDuration(data.idleDiscardedSecs)}.`,
          action: data.idleDiscardedSecs > 0 ? 'Discarded idle time does not count toward tracked hours.' : null,
          techDetail: null
        });
      }

      // === TIMEZONE ===
      if (data.timezone) {
        findings.push({
          severity: 'info',
          icon: 'üåç',
          title: `Timezone: UTC${data.timezone}`,
          description: `User's computer timezone offset detected from logs.`,
          action: null,
          techDetail: null
        });
      }

      // === APP VERSION CHECK ===
      // Detect app version and platform from logs
      let appVersion = null;
      let appPlatform = null;
      let buildNumber = null;
      let versionLine = null;
      
      // Search for version patterns in logs
      for (const line of allLines) {
        // iOS: "2.2.72-100174-main-g77190d27" or "Hubstaff/2.2.72"
        if (!appVersion && (line.includes('Hubstaff/') || line.includes('CFBundle') || line.includes('-main-g'))) {
          const iosMatch = line.match(/(\d+\.\d+\.\d+)-(\d+)-main-g([a-f0-9]+)/i) ||
                          line.match(/Hubstaff\/(\d+\.\d+\.\d+)/) ||
                          line.match(/CFBundleShortVersionString[:\s]+(\d+\.\d+\.\d+)/);
          if (iosMatch) {
            appVersion = iosMatch[1];
            if (iosMatch[2]) buildNumber = iosMatch[2];
            appPlatform = 'iOS';
            versionLine = line;
          }
        }
        
        // Android: "2.2.75-63528" or "versionName=2.2.75"
        if (!appVersion && (line.includes('versionName') || line.match(/\d+\.\d+\.\d+-\d{4,}/))) {
          const androidMatch = line.match(/(\d+\.\d+\.\d+)-(\d{4,})/) ||
                               line.match(/versionName[=:\s]+(\d+\.\d+\.\d+)/);
          if (androidMatch) {
            appVersion = androidMatch[1];
            if (androidMatch[2]) buildNumber = androidMatch[2];
            appPlatform = 'Android';
            versionLine = line;
          }
        }
        
        // Windows/Mac/Linux desktop: "Version: 1.6.8" or "Hubstaff Desktop 1.6.8"
        if (!appVersion && (line.includes('Hubstaff Desktop') || line.includes('Desktop Version'))) {
          const desktopMatch = line.match(/(\d+\.\d+\.\d+)/);
          if (desktopMatch) {
            appVersion = desktopMatch[1];
            versionLine = line;
            // Try to detect OS
            if (line.toLowerCase().includes('windows') || allLines.some(l => l.includes('Windows') || l.includes('win32'))) {
              appPlatform = 'Windows';
            } else if (line.toLowerCase().includes('mac') || allLines.some(l => l.includes('macOS') || l.includes('darwin'))) {
              appPlatform = 'Mac';
            } else if (line.toLowerCase().includes('linux') || allLines.some(l => l.includes('Linux') || l.includes('linux'))) {
              appPlatform = 'Linux';
            } else {
              appPlatform = 'Desktop';
            }
          }
        }
        
        // Chrome/Firefox Extension: "Extension Version: 1.5.2"
        if (!appVersion && (line.includes('Extension') && line.includes('Version'))) {
          const extMatch = line.match(/(\d+\.\d+\.\d+)/);
          if (extMatch) {
            appVersion = extMatch[1];
            versionLine = line;
            if (line.toLowerCase().includes('chrome') || allLines.some(l => l.includes('Chrome'))) {
              appPlatform = 'Chrome Extension';
            } else if (line.toLowerCase().includes('firefox') || allLines.some(l => l.includes('Firefox'))) {
              appPlatform = 'Firefox Extension';
            } else {
              appPlatform = 'Browser Extension';
            }
          }
        }
        
        // Chromebook
        if (!appVersion && (line.includes('Chromebook') || line.includes('ChromeOS') || line.includes('CrOS'))) {
          const chromeOsMatch = line.match(/(\d+\.\d+\.\d+)/);
          if (chromeOsMatch) {
            appVersion = chromeOsMatch[1];
            appPlatform = 'Chromebook';
            versionLine = line;
          }
        }
        
        // Web Timer
        if (!appVersion && (line.includes('Web Timer') || line.includes('web-timer'))) {
          const webMatch = line.match(/(\d+\.\d+\.\d+)/);
          if (webMatch) {
            appVersion = webMatch[1];
            appPlatform = 'Web Timer';
            versionLine = line;
          }
        }
        
        // Generic fallback: "App Version: X.X.X" or "Client Version: X.X.X"
        if (!appVersion && (line.includes('App Version') || line.includes('Client Version') || line.includes('APPLICATION_VERSION'))) {
          const genericMatch = line.match(/(\d+\.\d+\.\d+)/);
          if (genericMatch) {
            appVersion = genericMatch[1];
            versionLine = line;
          }
        }
        
        // Stop searching once we found a version
        if (appVersion) break;
      }
      
      // Detect platform from other indicators if not already set
      if (!appPlatform) {
        if (allLines.some(line => line.includes('UIKit') || line.includes('kCLErrorDomain') || line.includes('CoreLocation'))) {
          appPlatform = 'iOS';
        } else if (allLines.some(line => line.includes('android.') || line.match(/manufacturer\s*:/i) || line.includes('Xiaomi') || line.includes('Samsung'))) {
          appPlatform = 'Android';
        } else if (allLines.some(line => line.includes('WindowsInput') || line.includes('win32') || line.includes('Windows'))) {
          appPlatform = 'Windows';
        } else if (allLines.some(line => line.includes('macOS') || line.includes('darwin') || line.includes('NSApplication'))) {
          appPlatform = 'Mac';
        } else if (allLines.some(line => line.includes('Linux') && !line.includes('linux-'))) {
          appPlatform = 'Linux';
        }
      }
      
      // Known problematic versions (update as needed)
      const PROBLEMATIC_VERSIONS = {
        'iOS': {
          '2.2.68': 'Known bug causing locations to temporarily stop uploading.',
          '2.2.65': 'Issues with background location tracking on some devices.',
        },
        'Android': {
          '2.2.68': 'Geofence detection reliability issues.',
        },
        'Windows': {},
        'Mac': {},
        'Linux': {},
      };
      
      if (appVersion) {
        const platformProblems = PROBLEMATIC_VERSIONS[appPlatform] || {};
        const isProblematic = platformProblems[appVersion];
        
        const fullVersionString = buildNumber ? `${appVersion}-${buildNumber}` : appVersion;
        const platformIcon = {
          'iOS': 'üçé',
          'Android': 'ü§ñ',
          'Windows': 'ü™ü',
          'Mac': 'üçé',
          'Linux': 'üêß',
          'Chrome Extension': 'üåê',
          'Firefox Extension': 'ü¶ä',
          'Chromebook': 'üíª',
          'Web Timer': 'üåê',
          'Desktop': 'üñ•Ô∏è',
          'Browser Extension': 'üîå',
        }[appPlatform] || 'üì±';
        
        if (isProblematic) {
          findings.push({
            severity: 'critical',
            icon: platformIcon,
            title: `${appPlatform || 'App'} Version: ${fullVersionString} ‚ö†Ô∏è KNOWN ISSUES`,
            description: `<strong>${isProblematic}</strong>`,
            action: `Have the user update to the latest version immediately.`,
            techDetail: versionLine ? versionLine.slice(0, 200) : null
          });
        } else {
          findings.push({
            severity: 'info',
            icon: platformIcon,
            title: `${appPlatform || 'App'} Version: ${fullVersionString}`,
            description: `Detected from logs. <a href="https://app.hubstaff.com/admin/releases" target="_blank" style="color:var(--link);">Check releases page</a> to verify if current.`,
            action: null,
            techDetail: versionLine ? versionLine.slice(0, 200) : null
          });
        }
      } else {
        // No version detected
        findings.push({
          severity: 'info',
          icon: '‚ùì',
          title: 'App Version: Not Detected',
          description: 'Could not find app version in logs. This may be a partial log or the version info was not captured.',
          action: 'Ask the user for their app version from Settings > About, or check the device info in the Admin panel.',
          techDetail: null
        });
      }

      // === iOS PERMISSION STATUS CHECK ===
      const permissionLine = allLines.find(line => line.includes('SESSION:') && line.includes('device_locations='));
      if (permissionLine) {
        const locPermMatch = permissionLine.match(/device_locations=(\w+)/);
        if (locPermMatch) {
          const permStatus = locPermMatch[1];
          if (permStatus === 'undetermined') {
            findings.push({
              severity: 'critical',
              icon: 'üìç',
              title: 'Location Permission Not Yet Granted',
              description: `iOS location permission is <strong>undetermined</strong> - the user has not yet responded to the location permission prompt or it was never shown.`,
              action: 'User needs to: 1) Open Hubstaff app and approve location prompt if shown, OR 2) Go to iOS Settings ‚Üí Privacy & Security ‚Üí Location Services ‚Üí Hubstaff ‚Üí select "Always" and enable "Precise Location".',
              techDetail: permissionLine
            });
          } else if (permStatus === 'denied') {
            findings.push({
              severity: 'critical',
              icon: 'üö´',
              title: 'Location Permission Denied',
              description: `iOS location permission is <strong>denied</strong>. The app cannot access location at all.`,
              action: 'User must go to iOS Settings ‚Üí Privacy & Security ‚Üí Location Services ‚Üí Hubstaff ‚Üí select "Always". They may have accidentally denied the prompt.',
              techDetail: permissionLine
            });
          } else if (permStatus === 'restricted') {
            findings.push({
              severity: 'critical',
              icon: 'üîí',
              title: 'Location Permission Restricted',
              description: `iOS location permission is <strong>restricted</strong> by device management (MDM) or parental controls.`,
              action: 'Contact the IT administrator who manages this device. They need to allow location access for Hubstaff in the MDM profile.',
              techDetail: permissionLine
            });
          } else if (permStatus === 'authorizedWhenInUse') {
            findings.push({
              severity: 'warning',
              icon: '‚ö†Ô∏è',
              title: 'Location Set to "While Using" - Insufficient',
              description: `iOS location permission is set to <strong>"While Using App"</strong>. This is NOT sufficient for background location tracking. Locations will only be recorded while the app is open and on screen.`,
              action: 'User must go to iOS Settings ‚Üí Hubstaff ‚Üí Location ‚Üí change from "While Using the App" to "Always". Background tracking requires "Always" permission.',
              techDetail: permissionLine
            });
          }
        }
      }

      // === iOS LOCATION ERROR CHECK ===
      const locationDeniedError = allLines.find(line => line.includes('kCLErrorDomain Code=1') || (line.includes('[Position]') && line.includes('denied')));
      if (locationDeniedError && !findings.some(f => f.title.includes('Permission Denied'))) {
        findings.push({
          severity: 'critical',
          icon: 'üö´',
          title: 'iOS Blocked Location Request',
          description: `Found iOS error <strong>kCLErrorDomain Code=1</strong> which means iOS actively denied a location request. Even if the app has internal consent, iOS is blocking location access.`,
          action: 'This is the smoking gun! User must change iOS location permission: Settings ‚Üí Privacy & Security ‚Üí Location Services ‚Üí Hubstaff ‚Üí "Always".',
          techDetail: locationDeniedError.slice(0, 200)
        });
      }

      // === PERMISSION MISMATCH CHECK ===
      const appConsentsLocation = allLines.find(line => line.includes('consents') && line.includes('locations') && line.includes('true'));
      const iosLocationDenied = allLines.some(line => line.includes('device_locations=denied') || line.includes('device_locations=undetermined') || (line.includes('kCLErrorDomain') && line.includes('Code=1')));
      
      if (appConsentsLocation && iosLocationDenied) {
        findings.push({
          severity: 'critical',
          icon: 'üîÄ',
          title: 'Permission Mismatch Detected',
          description: `The Hubstaff app has location consent enabled (<code>consents.locations: true</code>), but iOS is blocking location access. The user agreed to tracking in the app but iOS permissions are wrong.`,
          action: 'This explains the issue! The app thinks it has permission but iOS disagrees. Fix: iOS Settings ‚Üí Privacy & Security ‚Üí Location Services ‚Üí Hubstaff ‚Üí "Always".',
          techDetail: 'App consent: ' + (appConsentsLocation ? appConsentsLocation.slice(0, 100) : 'found')
        });
      }

      // === ANDROID BATTERY OPTIMIZATION CHECK ===
      const batteryOptLine = allLines.find(line => line.includes('isIgnoringBatteryOptimization'));
      if (batteryOptLine) {
        const isIgnoring = batteryOptLine.includes('isIgnoringBatteryOptimization: =true');
        if (!isIgnoring) {
          findings.push({
            severity: 'warning',
            icon: 'üîã',
            title: 'Battery Optimization NOT Disabled',
            description: `Android battery optimization is <strong>active</strong> for Hubstaff. This means Android may kill the app in the background to save battery, causing tracking gaps and missed notifications.`,
            action: 'Disable battery optimization: Settings ‚Üí Apps ‚Üí Hubstaff ‚Üí Battery ‚Üí "Unrestricted". Samsung: Also check Device Care ‚Üí Battery ‚Üí App power management.',
            techDetail: batteryOptLine.slice(0, 200)
          });
        }
      }

      // === ANDROID REPEATED CRASH/KILL CHECK ===
      const uncleanCount = allLines.filter(line => line.includes('STARTUP_UNCLEAN')).length;
      if (uncleanCount > 5) {
        findings.push({
          severity: 'critical',
          icon: 'üí•',
          title: `App Killed/Crashed ${uncleanCount} Times`,
          description: `Found <strong>${uncleanCount}</strong> unclean startup events. The app is being repeatedly killed by Android or crashing. This is very likely caused by aggressive battery optimization.`,
          action: '1) Disable battery optimization for Hubstaff, 2) On Samsung: Check "Sleeping apps" and "Deep sleeping apps" lists - remove Hubstaff, 3) Enable "Autostart" if available on your device.',
          techDetail: `Found ${uncleanCount} STARTUP_UNCLEAN events in logs`
        });
      } else if (uncleanCount > 0) {
        findings.push({
          severity: 'warning',
          icon: '‚ö†Ô∏è',
          title: `App Crashed/Force-Closed ${uncleanCount} Time${uncleanCount > 1 ? 's' : ''}`,
          description: `The app detected ${uncleanCount} unclean shutdown${uncleanCount > 1 ? 's' : ''} from previous sessions.`,
          action: 'Check if user is force-closing the app or if battery optimization is killing it in the background.',
          techDetail: null
        });
      }

      // === ANDROID JOB SITE RESTRICTION BLOCK CHECK ===
      const jobSiteBlocks = allLines.filter(line => line.includes('TRACKING_NOT_STARTED') || line.includes('requires being at a job site'));
      if (jobSiteBlocks.length > 0) {
        findings.push({
          severity: 'critical',
          icon: 'üö´',
          title: `Timer Blocked ${jobSiteBlocks.length} Times - Not At Job Site`,
          description: `User attempted to start the timer <strong>${jobSiteBlocks.length}</strong> time${jobSiteBlocks.length > 1 ? 's' : ''} but was blocked because they are not at a job site. The organization has "Restrict timer to job sites" enabled.`,
          action: 'User must be physically at a configured job site to start tracking. If they ARE at a site: 1) GPS accuracy issue - try going outdoors with clear sky, 2) Job site radius may be too small - increase to 100-150m, 3) Job site pin location may be wrong on the map.',
          techDetail: jobSiteBlocks.slice(0,3).map(l => l.slice(0, 120)).join('\n')
        });
      }

      // === ANDROID DNS/NETWORK FAILURE CHECK ===
      const dnsErrors = allLines.filter(line => line.includes('Could not resolve host') || line.includes('UnknownHostException'));
      if (dnsErrors.length > 0) {
        findings.push({
          severity: 'critical',
          icon: 'üåê',
          title: `Network/DNS Failures Detected (${dnsErrors.length} errors)`,
          description: `Found <strong>${dnsErrors.length}</strong> DNS resolution failures. The device could not reach Hubstaff servers because there was no working internet connection during these times.`,
          action: 'Check: 1) WiFi or mobile data is ON, 2) Airplane mode is OFF, 3) Try switching between WiFi and cellular, 4) Restart the device. Data cannot sync without internet.',
          techDetail: dnsErrors.slice(0,2).map(l => l.slice(0, 100)).join('\n')
        });
      }

      // === ANDROID DEVICE DETECTION ===
      const deviceLine = allLines.find(line => line.includes('device manufacturer'));
      if (deviceLine) {
        const mfgMatch = deviceLine.match(/manufacturer\s*:\s*(\w+)/i);
        const modelMatch = deviceLine.match(/model:\s*([\w-]+)/i);
        const osMatch = deviceLine.match(/OS:\s*(\d+)/i);
        
        if (mfgMatch || modelMatch) {
          const manufacturer = mfgMatch ? mfgMatch[1] : 'Unknown';
          const model = modelMatch ? modelMatch[1] : 'Unknown';
          const osVersion = osMatch ? osMatch[1] : 'Unknown';
          
          let deviceWarning = null;
          // Brand-specific battery warnings
          if (manufacturer.toLowerCase() === 'samsung') {
            deviceWarning = 'Samsung devices have aggressive battery optimization. Ensure Hubstaff is set to "Unrestricted" and NOT in "Sleeping apps" or "Deep sleeping apps" lists.';
          } else if (manufacturer.toLowerCase() === 'xiaomi' || manufacturer.toLowerCase() === 'redmi') {
            deviceWarning = 'Xiaomi/MIUI has very aggressive battery management. Enable "Autostart" for Hubstaff and disable all battery restrictions.';
          } else if (manufacturer.toLowerCase() === 'huawei') {
            deviceWarning = 'Huawei restricts background apps heavily. Add Hubstaff to "Protected Apps" and disable power-saving for it.';
          } else if (manufacturer.toLowerCase() === 'oppo' || manufacturer.toLowerCase() === 'realme') {
            deviceWarning = 'OPPO/Realme has aggressive app killing. Enable "Allow Auto-start" and disable battery optimization for Hubstaff.';
          } else if (manufacturer.toLowerCase() === 'oneplus') {
            deviceWarning = 'OnePlus: Settings ‚Üí Battery ‚Üí Battery Optimization ‚Üí Hubstaff ‚Üí Don\'t optimize.';
          }
          
          findings.push({
            severity: deviceWarning ? 'info' : 'info',
            icon: 'üì±',
            title: `Android Device: ${manufacturer} ${model} (API ${osVersion})`,
            description: `Detected Android device from logs.`,
            action: deviceWarning,

          });
        }
      }

      // === INJECTED INPUT ===
      if (data.injected.length > 0) {
        const onlyInjected = data.injected.filter(e => e.msg.toLowerCase().includes('only injected'));
        const simulated = data.injected.filter(e => e.msg.toLowerCase().includes('simulated'));
        
        let desc = `Detected ${data.injected.length} injected/simulated input event${data.injected.length > 1 ? 's' : ''}.`;
        if (onlyInjected.length > 0) desc += ` ${onlyInjected.length} showed ONLY injected input (no real input).`;
        
        findings.push({
          severity: onlyInjected.length > 10 ? 'warning' : 'info',
          icon: 'ü§ñ',
          title: `Injected Input: ${data.injected.length} Events`,
          description: desc + ` <strong>Common causes:</strong> Remote desktop, accessibility tools, automation software, gaming peripherals with macros.`,
          action: onlyInjected.length > 10 ? 
            'High number of "only injected" events. Check if user is using remote desktop or automation tools. Review screenshots for patterns.' : 
            'Some injected input detected. This is often normal - check the Injected Input section for details.',
          techDetail: data.injected.slice(0,5).map(e => `${fmtTime(e.ts)}: ${e.msg.slice(0,80)}`).join('\n')
        });
      }
      
      // Check for critical issues
      // === iOS/LOCATION SPECIFIC ISSUES ===
      const nonPrimaryIssues = data.locations.filter(e => e.msg.toLowerCase().includes('not primary') || e.msg.toLowerCase().includes('non-primary'));
      const locationUnavailable = data.locations.filter(e => e.msg.toLowerCase().includes('unavailable') || e.msg.toLowerCase().includes('denied'));
      const mustVisitSite = data.locations.filter(e => e.msg.toLowerCase().includes('must visit'));
      const simulatedLocations = data.locations.filter(e => e.msg.toLowerCase().includes('simulated location'));
      const siteEnters = data.locations.filter(e => e.msg.includes('ENTER'));
      const siteExits = data.locations.filter(e => e.msg.includes('EXIT'));
      const autoStartEvents = data.locations.filter(e => e.msg.toLowerCase().includes('auto-start'));
      const autoStopEvents = data.locations.filter(e => e.msg.toLowerCase().includes('auto-stop'));
      
      if (nonPrimaryIssues.length > 0) {
        findings.push({
          severity: 'warning', icon: 'üì±', title: 'Non-Primary Device Issues',
          description: `Found ${nonPrimaryIssues.length} event${nonPrimaryIssues.length > 1 ? 's' : ''} where actions were blocked because this isn't the primary device. <strong>Only the primary device can record locations and trigger job site automations.</strong>`,
          action: 'Have the user tap the "Make Primary" banner on the Timer screen, or check which device is primary in Admin ‚Üí User ‚Üí Primary Device.',
          techDetail: nonPrimaryIssues.slice(0,3).map(e => `${fmtTime(e.ts)}: ${e.msg.slice(0,100)}`).join('\n')
        });
      }
      
      if (locationUnavailable.length > 0) {
        findings.push({
          severity: 'critical', icon: 'üìç', title: 'Location Unavailable',
          description: `Found ${locationUnavailable.length} event${locationUnavailable.length > 1 ? 's' : ''} where location was unavailable. This prevents job site features and may block tracking if "Restrict timer to job sites" is enabled.`,
          action: '<strong>iOS:</strong> Settings ‚Üí Privacy & Security ‚Üí Location Services ‚Üí ON, then Settings ‚Üí Hubstaff ‚Üí Location ‚Üí Always + Precise Location ON. <strong>Android:</strong> Enable location permission with "Allow all the time" + High Accuracy mode.',
          techDetail: locationUnavailable.slice(0,3).map(e => `${fmtTime(e.ts)}: ${e.msg.slice(0,100)}`).join('\n')
        });
      }
      
      if (mustVisitSite.length > 0) {
        findings.push({
          severity: 'critical', icon: 'üö´', title: 'Timer Blocked - Not At Job Site',
          description: `Found ${mustVisitSite.length} attempt${mustVisitSite.length > 1 ? 's' : ''} to start the timer that were blocked because the user wasn't at a job site. The organization has "Restrict timer to job sites" enabled.`,
          action: 'User must be physically at a configured job site to start tracking. If they ARE at the site, this could be a GPS accuracy issue - consider increasing the job site radius to 100-150m.',
          techDetail: mustVisitSite.slice(0,3).map(e => `${fmtTime(e.ts)}: ${e.msg.slice(0,100)}`).join('\n')
        });
      }
      
      if (simulatedLocations.length > 0) {
        findings.push({
          severity: 'critical', icon: 'üö´', title: 'Fake/Simulated Locations Detected',
          description: `Found ${simulatedLocations.length} simulated (fake) location${simulatedLocations.length > 1 ? 's' : ''} that were blocked. The user may be using a GPS spoofing app.`,
          action: 'Hubstaff blocks fake locations. If legitimate, user may have a developer/mock location app enabled that needs to be disabled.',
          techDetail: simulatedLocations.slice(0,3).map(e => `${fmtTime(e.ts)}: ${e.msg.slice(0,100)}`).join('\n')
        });
      }
      
      if (siteEnters.length > 0 || siteExits.length > 0) {
        let siteDesc = '';
        if (siteEnters.length > 0) siteDesc += `${siteEnters.length} site entry event${siteEnters.length > 1 ? 's' : ''}`;
        if (siteEnters.length > 0 && siteExits.length > 0) siteDesc += ' and ';
        if (siteExits.length > 0) siteDesc += `${siteExits.length} site exit event${siteExits.length > 1 ? 's' : ''}`;
        const autoActions = autoStartEvents.length + autoStopEvents.length;
        if (autoActions > 0) siteDesc += `. ${autoActions} automation action${autoActions > 1 ? 's' : ''} triggered.`;
        findings.push({ severity: 'success', icon: 'üìç', title: 'Job Site Activity Detected', description: siteDesc, action: null, techDetail: null });
      }
      const watchdogHits = data.errors.filter(e => e.msg.toLowerCase().includes('watchdog'));
      if (watchdogHits.length > 0) {
        findings.push({
          severity: 'critical',
          icon: 'ü•∂',
          title: `App Froze ${watchdogHits.length} Time${watchdogHits.length > 1 ? 's' : ''}`,
          description: 'The Hubstaff app became unresponsive and had to recover. This can cause gaps in tracking.',
          action: 'Ask the user if the app felt slow or frozen. They may need to restart Hubstaff or their computer.',
          techDetail: watchdogHits.slice(0,3).map(e => `${fmtTime(e.ts)}: ${e.msg.slice(0,100)}`).join('\n')
        });
      }
      
      const helperCrashes = data.errors.filter(e => e.msg.toLowerCase().includes('helper died') || e.msg.toLowerCase().includes('helper crash'));
      if (helperCrashes.length > 0) {
        findings.push({
          severity: 'critical',
          icon: 'üîå',
          title: 'Browser Extension Crashed',
          description: 'The Hubstaff browser extension stopped working. This affects URL and app tracking.',
          action: 'Have the user reinstall the browser extension and restart their browser.',
          techDetail: helperCrashes.slice(0,3).map(e => `${fmtTime(e.ts)}: ${e.msg.slice(0,100)}`).join('\n')
        });
      }
      
      const serverErrors = data.network.filter(e => e.msg.match(/response:\s*5\d{2}/i));
      if (serverErrors.length > 0) {
        findings.push({
          severity: 'critical',
          icon: 'üåê',
          title: `${serverErrors.length} Server Error${serverErrors.length > 1 ? 's' : ''} Detected`,
          description: 'Hubstaff servers returned errors. This may have prevented data from uploading.',
          action: 'Check status.hubstaff.com for any reported outages during this time period.',
          techDetail: serverErrors.slice(0,3).map(e => `${fmtTime(e.ts)}: ${e.msg.slice(0,100)}`).join('\n')
        });
      }
      
      const authErrors = data.network.filter(e => e.msg.match(/response:\s*(401|403)/i));
      if (authErrors.length > 0) {
        findings.push({
          severity: 'critical',
          icon: 'üîê',
          title: 'Authentication Problems',
          description: 'The user\'s login session may have expired or their permissions changed.',
          action: 'Have the user log out of Hubstaff completely and log back in.',
          techDetail: authErrors.slice(0,3).map(e => `${fmtTime(e.ts)}: ${e.msg.slice(0,100)}`).join('\n')
        });
      }
      
      const discards = data.warnings.filter(e => e.msg.toLowerCase().includes('discard='));
      if (discards.length > 0) {
        const lockedDiscards = discards.filter(e => e.msg.toLowerCase().includes('locked'));
        const futureDiscards = discards.filter(e => e.msg.toLowerCase().includes('future'));
        
        if (lockedDiscards.length > 0) {
          findings.push({
            severity: 'critical',
            icon: 'üîí',
            title: 'Time Rejected - Timesheet Locked',
            description: 'Some tracked time was rejected because the timesheet was already approved/locked.',
            action: 'An admin needs to unlock the timesheet, or time must be added to a different date.',
            techDetail: lockedDiscards.slice(0,3).map(e => `${fmtTime(e.ts)}: ${e.msg.slice(0,100)}`).join('\n')
          });
        }
        if (futureDiscards.length > 0) {
          findings.push({
            severity: 'critical',
            icon: '‚è∞',
            title: 'Time Rejected - Clock Problem',
            description: 'Time was rejected because the computer\'s clock was set incorrectly (in the future).',
            action: 'Have the user check their system date/time settings and enable automatic time.',
            techDetail: futureDiscards.slice(0,3).map(e => `${fmtTime(e.ts)}: ${e.msg.slice(0,100)}`).join('\n')
          });
        }
      }
      
      const memoryIssues = data.warnings.filter(e => e.msg.toLowerCase().includes('memory'));
      if (memoryIssues.length > 0) {
        findings.push({
          severity: 'warning',
          icon: 'üíæ',
          title: 'Low Memory Warnings',
          description: 'The computer was running low on memory (RAM), which can slow down Hubstaff.',
          action: 'Suggest the user close unused programs or browser tabs.',
          techDetail: memoryIssues.slice(0,3).map(e => `${fmtTime(e.ts)}: ${e.msg.slice(0,100)}`).join('\n')
        });
      }
      
      const locationDenied = data.locations.filter(e => e.msg.toLowerCase().includes('denied') || e.msg.toLowerCase().includes('restricted'));
      if (locationDenied.length > 0) {
        findings.push({
          severity: 'warning',
          icon: 'üìç',
          title: 'Location Permission Issues',
          description: 'Location permissions were denied. Job Sites features won\'t work properly.',
          action: 'Have the user enable "Always" location permission for Hubstaff in their device settings.',
          techDetail: locationDenied.slice(0,3).map(e => `${fmtTime(e.ts)}: ${e.msg.slice(0,100)}`).join('\n')
        });
      }

      // === BRAVE BROWSER CHECK ===
const braveUsage = data.apps.filter(e => 
  (e.extractedApp && e.extractedApp.toLowerCase().includes('brave')) ||
  (e.raw && e.raw.toLowerCase().includes('brave')) ||
  (e.msg && e.msg.toLowerCase().includes('brave'))
);

// Also check all lines for Brave in PutApplications blocks
const braveInLogs = allLines.some(line => 
  line.includes('name') && line.toLowerCase().includes('brave')
);
      if (braveUsage.length > 0 || braveInLogs) {
  findings.push({
    severity: 'warning',
    icon: 'ü¶Å',
    title: 'Brave Browser Detected - URL Tracking Not Supported',
    description: `Brave Browser usage detected in logs. <strong>Hubstaff does not support URL tracking in Brave Browser.</strong> The app name will be tracked, but visited URLs will not appear in reports.`,
    action: 'For URL tracking on Windows, the user should switch to a supported browser: Google Chrome, Microsoft Edge, Firefox, or Island Browser.',
    techDetail: braveUsage.length > 0 ? braveUsage.slice(0,3).map(e => `${fmtTime(e.ts)}: ${e.extractedApp || 'Brave Browser'}`).join('\n') : 'Detected in PutApplications block'
  });
}
      
      // Positive findings
      if (data.screenshots.length > 0 && !data.screenshots.some(e => e.msg.toLowerCase().includes('fail') || e.msg.toLowerCase().includes('error'))) {
        findings.push({
          severity: 'success',
          icon: 'üì∏',
          title: `${data.screenshots.length} Screenshots Captured`,
          description: 'Screenshots were captured and uploaded successfully during this period.',
          action: null,
          techDetail: null
        });
      }
      
      if (findings.length === 0) {
        findings.push({
          severity: 'success',
          icon: '‚úÖ',
          title: 'No Major Issues Detected',
          description: 'The logs look healthy. No critical errors or warnings were found.',
          action: 'If the user is still experiencing issues, ask for more specific details about what\'s happening.',
          techDetail: null
        });
      }
      
      return findings;
    }

    function hideInfoBox() {
      $('infoBox').style.display = 'none';
      if (selectedMarker) { selectedMarker.style.outline = 'none'; selectedMarker = null; }
    }

    function showInfoBox(e, title, content) {
      const box = $('infoBox');
      $('infoTitle').textContent = title;
      $('infoContent').innerHTML = content;
      box.style.display = 'block';

      const rect = box.getBoundingClientRect();
      // Use pageX/pageY to account for scroll position
      let top = e.pageY - rect.height - 15;
      let left = e.pageX - rect.width / 2;
      
      // Keep within viewport bounds (using scroll-adjusted values)
      const scrollTop = window.pageYOffset || document.documentElement.scrollTop;
      const scrollLeft = window.pageXOffset || document.documentElement.scrollLeft;
      
      if (top < scrollTop + 10) top = e.pageY + 15;
      if (left < scrollLeft + 10) left = scrollLeft + 10;
      if (left + rect.width > scrollLeft + window.innerWidth - 10) {
        left = scrollLeft + window.innerWidth - rect.width - 10;
      }

      box.style.top = top + 'px';
      box.style.left = left + 'px';
    }

    function renderTimeline(data) {
      if (!data || !data.startTime || !data.endTime) {
        $('timelineSection').style.display = 'none';
        return;
      }

      const min = new Date(data.startTime.getTime() - 60000);
      const max = new Date(data.endTime.getTime() + 60000);
      timelineMin = min;
      timelineDur = max - min;

      const pos = ts => ts ? ((ts - min) / timelineDur) * 100 : 0;

      function renderMarkers(items, trackId, cls) {
        const track = $(trackId);
        if (!items.length) { track.innerHTML = ''; return; }
        
        track.innerHTML = items.map((item, i) => {
          const left = pos(item.ts);
          return `<div class="t-marker ${cls}" data-idx="${i}" data-type="${cls}" style="left:${left}%"></div>`;
        }).join('');

        track.querySelectorAll('.t-marker').forEach((el, i) => {
          el.addEventListener('click', e => {
            e.stopPropagation();
            hideInfoBox();
            selectedMarker = el;
            el.style.outline = '2px solid #fff';

            const item = items[i];
            const plainMode = $('plainMode').checked;
            const translation = plainMode ? translateToPlainEnglish(item.msg, item.level, item.src) : null;
            
            let content = `<p><span class="label">Time:</span> ${fmtDate(item.ts)}</p>`;
            if (translation) {
              content += `<p style="color:var(--accent);margin:8px 0;">${translation.text}</p>`;
              if (translation.action) {
                content += `<p style="font-size:11px;color:var(--success);">üí° ${translation.action}</p>`;
              }
            }
            content += `<p><span class="label">Level:</span> ${item.level}</p>`;
            content += `<p><span class="label">Source:</span> ${escapeHtml(item.src || 'N/A')}</p>`;
            content += `<div class="msg">${escapeHtml(item.msg.slice(0, 300))}</div>`;
            
            const titleText = translation ? translation.text.replace(/^[^\s]+\s/, '') : cls.charAt(0).toUpperCase() + cls.slice(1) + ' Event';
            showInfoBox(e, titleText.slice(0, 40), content);
          });
        });
      }

      renderMarkers(data.errors, 'trackErrors', 'error');
      renderMarkers(data.warnings, 'trackWarnings', 'warn');
      renderMarkers(data.screenshots, 'trackScreenshots', 'screenshot');
      renderMarkers(data.network, 'trackNetwork', 'network');
      renderMarkers(data.locations, 'trackLocation', 'location');
      renderMarkers(data.tracking, 'trackTracking', 'tracking');

      $('tlErrorCount').textContent = data.errors.length;
      $('tlWarnCount').textContent = data.warnings.length;
      $('tlScreenCount').textContent = data.screenshots.length;
      $('tlNetCount').textContent = data.network.length;
      $('tlLocCount').textContent = data.locations.length;
      $('tlTrackCount').textContent = data.tracking.length;

      // Time axis
      const axisPoints = 7;
      let axisHtml = '';
      for (let i = 0; i < axisPoints; i++) {
        const t = new Date(min.getTime() + (timelineDur * i / (axisPoints - 1)));
        axisHtml += `<span>${t.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})}</span>`;
      }
      $('timeAxis').innerHTML = axisHtml;

      $('timelineSection').style.display = 'block';
    }

    function analyze(text) {
      const lines = text.split(/\r?\n/).filter(l => l.trim());
      allLines = lines;

      const data = {
        total: lines.length,
        errors: [],
        warnings: [],
        screenshots: [],
        network: [],
        locations: [],
        apps: [],
        tracking: [],
        injected: [],
        sessions: [],
        idleDecisions: [],
        idleKeptSecs: 0,
        idleDiscardedSecs: 0,
        timezone: null,
        startTime: null,
        endTime: null,
        jobSites: [],
        userLocations: [],
        currentlyEnteredSites: [],
        geofenceEvents: []
      };

      const showDebug = $('showDebug').checked;
      const showTrace = $('showTrace').checked;
      
      let openSession = null;
      let lastIdleWakeSecs = null;
      let lastIdleWakeTime = null;

      for (const line of lines) {
        const ts = parseTimestamp(line);
        const level = parseLevel(line);
        const src = parseSource(line);
        const msg = parseMessage(line);

        if (ts) {
          if (!data.startTime || ts < data.startTime) data.startTime = ts;
          if (!data.endTime || ts > data.endTime) data.endTime = ts;
        }

        // Extract timezone from first line that has one
        if (!data.timezone) {
          const tz = parseTimezone(line);
          if (tz) data.timezone = tz;
        }
        
        // Also check for TZ Offset line specifically (higher priority)
        if (line.includes('TZ Offset')) {
          const tz = parseTimezone(line);
          if (tz) {
            data.timezone = tz;
            // Auto-fill timezone input if empty
            if (!$('tzOffset').value) {
              $('tzOffset').value = tz;
              updateTzLabel();
            }
          }
        }

        // Skip DEBUG/TRACE unless enabled, BUT always process ApplicationGrabber URL/APP lines
const isAppGrabberUrl = line.includes('ApplicationGrabber') && line.includes('URL:');
const isAppActivity = line.includes('Switched to app') || line.includes('for App :') || (line.includes('WindowsGrabber') && line.includes('name:'));
const isPutApplications = line.includes('PutApplications');
if (!showDebug && level === 'DEBUG' && !isAppGrabberUrl && !isAppActivity && !isPutApplications) continue;
if (!showTrace && level === 'TRACE') continue;

        const entry = { ts, level, src, msg, raw: line };

        // === SESSION TRACKING (START/STOP) ===
        if (line.includes('START_TRACKING') || line.includes('Tracking Started')) {
          let reason = 'USER';
          if (line.includes('[RESUMED]') || line.toLowerCase().includes('resumed')) reason = 'RESUMED';
          else if (line.includes('[IDLE]')) reason = 'IDLE';
          
          if (openSession) {
            // Unclosed session - mark as crashed
            openSession.stop = ts;
            openSession.stopReason = 'CRASHED';
            openSession.duration = (openSession.stop - openSession.start) / 1000;
            data.sessions.push(openSession);
          }
          openSession = { start: ts, startReason: reason, stop: null, stopReason: null, duration: 0 };
        }
        
        if (line.includes('STOP_TRACKING') || line.includes('Tracking Stopped')) {
          let reason = 'USER';
          if (line.includes('[IDLE]')) reason = 'IDLE';
          else if (line.includes('[CONFIGURATION]')) reason = 'CONFIG';
          else if (line.includes('[PROJECT_CONFIGURATION_LOCATION]')) reason = 'LEFT_JOBSITE';
          else if (line.includes('[SHUTDOWN]')) reason = 'SHUTDOWN';
          
          if (openSession) {
            openSession.stop = ts;
            openSession.stopReason = reason;
            openSession.duration = (openSession.stop - openSession.start) / 1000;
            data.sessions.push(openSession);
            openSession = null;
          }
        }

        // === IDLE TRACKING ===
        // Capture IDLE_WAKE seconds
        if (line.includes('IDLE_WAKE') || (line.includes('Idle') && line.includes('wake'))) {
          const secsMatch = line.match(/(?:after|for)\s+(\d+)\s+seconds?/i);
          if (secsMatch) {
            lastIdleWakeSecs = parseInt(secsMatch[1]);
            lastIdleWakeTime = ts;
          }
        }
        
        // Capture idle decisions (KeepIdle / StopTracking)
        if (line.includes('KeepIdle') && line.includes('StopTracking')) {
          const keepMatch = line.match(/KeepIdle[:\s]+(\d+)/i);
          const stopMatch = line.match(/StopTracking[:\s]+(\d+)/i);
          const responseTimeMatch = line.match(/after\s+(\d+)\s+seconds?\s+with/i);
          
          const keepIdle = keepMatch ? keepMatch[1] === '1' : false;
          const stopTracking = stopMatch ? stopMatch[1] === '1' : false;
          const responseTimeSecs = responseTimeMatch ? parseInt(responseTimeMatch[1]) : null;
          
          const idleSecs = lastIdleWakeSecs || 0;
          const exceeds1Hour = idleSecs > 3600;
          
          // Determine the decision type
          // KeepIdle: 1 / StopTracking: 0 = User chose to KEEP idle time
          // KeepIdle: 0 / StopTracking: 1 = User chose to DISCARD and STOP tracking
          // KeepIdle: 0 / StopTracking: 0 = User chose to DISCARD idle but CONTINUE tracking
          let decision, decisionDetail;
          if (keepIdle) {
            decision = 'KEPT';
            decisionDetail = 'User clicked YES to keep idle time';
          } else if (stopTracking) {
            decision = 'DISCARDED_STOPPED';
            decisionDetail = 'User clicked NO and stopped tracking';
          } else {
            decision = 'DISCARDED_CONTINUED';
            decisionDetail = 'User clicked NO but continued tracking';
          }
          
          data.idleDecisions.push({
            ts: ts,
            seconds: idleSecs,
            decision: decision,
            decisionDetail: decisionDetail,
            keepIdle: keepIdle,
            stopTracking: stopTracking,
            responseTimeSecs: responseTimeSecs,
            exceeds1Hour: exceeds1Hour,
            rawValues: `KeepIdle: ${keepIdle ? '1' : '0'} / StopTracking: ${stopTracking ? '1' : '0'}`
          });
          
          if (keepIdle) {
            data.idleKeptSecs += idleSecs;
          } else {
            data.idleDiscardedSecs += idleSecs;
          }
          
          lastIdleWakeSecs = null;
        }

        // Errors
        if (level === 'ERROR' || line.includes('main_watchdog hit') || line.includes('Helper died') || line.includes('crash') || line.includes('FATAL')) {
          data.errors.push(entry);
        }

        // Warnings
        if (level === 'WARN' || line.includes('Discard=') || line.includes('OS Memory') || line.includes('Server Error') || line.includes('traffic issue')) {
          data.warnings.push(entry);
        }

        // Screenshots
        if (line.includes('Uploading Screen') || line.includes('Capture Screen') || line.includes('ScreenData') || line.includes('screenshot') || line.includes('Screenshot')) {
          data.screenshots.push(entry);
        }

        // Network
        if (line.match(/Response:\s*[45]\d{2}/) || line.includes('Server Error') || line.includes('Network') || line.includes('CURL') || line.includes('traffic issue')) {
          data.network.push(entry);
        }

        // Locations (expanded for iOS/Android location issues)
        if (line.includes('feed: sites') || line.includes('LocationFeatureState') || line.includes('LocationManager') || line.includes('geofence') || line.includes('Geofence') || line.includes('Job Site') || line.includes('[Site]') || line.includes('[Position]') || line.includes('[LocationRequest]') || line.includes('[LocationResolution]') || line.includes('primary device') || line.includes('Primary changed') || (line.toLowerCase().includes('location') && (line.includes('permission') || line.includes('unavailable') || line.includes('denied')))) {
          data.locations.push(entry);
        }

        // Apps & URLs - improved to handle multi-line URL/TITLE format
// Check if it's an ApplicationGrabber line with actual URL content
if (line.includes('ApplicationGrabber') && line.includes('URL:')) {
  const urlMatch = line.match(/URL:\s*(\S+)/);
  if (urlMatch && urlMatch[1]) {
    entry.extractedUrl = urlMatch[1];
    entry.extractedType = 'URL';
    data.apps.push(entry);
  }
}
// Skip standalone "TITLE:" lines that are empty or only whitespace
else if (line.match(/^TITLE:\s*$/) || line.match(/^\s*TITLE:\s*$/)) {
  // Skip empty TITLE lines - these are noise
}
// Capture TITLE lines that actually have content
else if (line.includes('TITLE:') && line.match(/TITLE:\s*\S+/)) {
  const titleMatch = line.match(/TITLE:\s*(.+)/);
  if (titleMatch && titleMatch[1].trim()) {
    entry.extractedTitle = titleMatch[1].trim();
    entry.extractedType = 'Title';
    data.apps.push(entry);
  }
}
// APP: lines (explicit format)
else if (line.includes('APP:')) {
  const appMatch = line.match(/APP:\s*(.+)/);
  if (appMatch && appMatch[1].trim()) {
    entry.extractedApp = appMatch[1].trim();
    entry.extractedType = 'App';
    data.apps.push(entry);
  }
}
// "Switched to app" lines
else if (line.includes('Switched to app')) {
  const appMatch = line.match(/Switched to app\s*:\s*(.+?)\s+at\s+\d+/i);
  if (appMatch && appMatch[1].trim() && !appMatch[1].includes('PII_HIDDEN')) {
    entry.extractedApp = appMatch[1].trim();
    entry.extractedType = 'App';
    data.apps.push(entry);
  }
}
// "Activating URL grabber for App" lines
else if (line.includes('for App :')) {
  const appMatch = line.match(/for App\s*:\s*(.+)/i);
  if (appMatch && appMatch[1].trim()) {
    entry.extractedApp = appMatch[1].trim();
    entry.extractedType = 'App';
    data.apps.push(entry);
  }
}
// WindowsGrabber "name:" lines (captures app name and version)
else if (line.includes('WindowsGrabber') && line.includes('name:')) {
  const appMatch = line.match(/name:\s*(.+?)\s+binary:/i);
  if (appMatch && appMatch[1].trim()) {
    entry.extractedApp = appMatch[1].trim();
    entry.extractedType = 'App';
    data.apps.push(entry);
  }
}

        // PutApplications JSON-style blocks - extract app names from name "AppName" or name AppName lines
else if (line.match(/^\s*name\s+["']?(.+?)["']?\s*$/)) {
  const appMatch = line.match(/^\s*name\s+["']?(.+?)["']?\s*$/);
  if (appMatch && appMatch[1].trim()) {
    const appName = appMatch[1].replace(/["']/g, '').trim();
    if (appName && appName !== 'applications' && appName !== 'platform') {
      entry.extractedApp = appName;
      entry.extractedType = 'App';
      data.apps.push(entry);
    }
  }
}

        // Tracking events
        if (line.includes('Resume') || line.includes('Idle') || line.includes('Discard=') || line.includes('Startup') || line.includes('START_TRACKING') || line.includes('STOP_TRACKING')) {
          data.tracking.push(entry);
        }

        // Job Sites / Geofences - extract site details
        if (line.includes('creating geofence') && !line.includes('id=-')) {
          const siteMatch = line.match(/id=(\d+),\s*name=([^,]+),\s*loc\s*\(([^,]+),\s*([^,]+),\s*(\d+)\)/);
          if (siteMatch) {
            data.jobSites.push({
              id: siteMatch[1],
              name: siteMatch[2].trim(),
              lat: parseFloat(siteMatch[3]),
              lng: parseFloat(siteMatch[4]),
              radius: parseInt(siteMatch[5]),
              ts: ts
            });
          }
        }

        // User's current location
        if (line.includes('current location is AppLocation')) {
          const locMatch = line.match(/latitude=([^,]+),\s*longitude=([^,]+),\s*hAccuracy=([^)]+)/);
          if (locMatch) {
            data.userLocations.push({
              ts: ts,
              lat: parseFloat(locMatch[1]),
              lng: parseFloat(locMatch[2]),
              accuracy: parseFloat(locMatch[3])
            });
          }
        }

        // Currently entered sites
        if (line.includes('currently entered sites are:')) {
          const sitesMatch = line.match(/currently entered sites are:\s*\[([^\]]*)\]/);
          if (sitesMatch) {
            data.currentlyEnteredSites.push({
              ts: ts,
              sites: sitesMatch[1].trim()
            });
          }
        }

        // Geofence ENTER/EXIT events (for visit history)
        if (line.includes('handling geofence event') && line.includes('transitionType=')) {
          const typeMatch = line.match(/transitionType=(\w+)/);
          const latMatch = line.match(/latitude=([\d.-]+)/);
          const lngMatch = line.match(/longitude=([\d.-]+)/);
          const accMatch = line.match(/hAccuracy=([\d.]+)/);
          
          if (typeMatch && latMatch && lngMatch) {
            data.geofenceEvents.push({
              ts: ts,
              type: typeMatch[1],
              lat: parseFloat(latMatch[1]),
              lng: parseFloat(lngMatch[1]),
              accuracy: accMatch ? parseFloat(accMatch[1]) : null
            });
          }
        }
      }

      return data;
    }

    function renderLevelTag(level) {
      const cls = level === 'ERROR' ? 'error' : level === 'WARN' ? 'warn' : level === 'AUDIT' ? 'audit' : level === 'INFO' ? 'info' : level === 'DEBUG' ? 'debug' : 'trace';
      return `<span class="tag ${cls}">${level}</span>`;
    }

    function render(data) {
      const plainMode = $('plainMode').checked;
      
      if (!data) {
        $('kpiTotal').textContent = '0';
        $('kpiErrors').textContent = '0';
        $('kpiWarnings').textContent = '0';
        $('kpiTrackedTime').textContent = '0:00:00';
        $('kpiIdleKept').textContent = '0:00:00';
        $('kpiIdleDisc').textContent = '0:00:00';
        $('kpiTimezone').textContent = '--';
        $('kpiTimeSpan').textContent = '--';
        $('errorsList').innerHTML = '<div class="event-item" style="color:var(--muted)">No errors found</div>';
        $('warningsList').innerHTML = '<div class="event-item" style="color:var(--muted)">No warnings found</div>';
        $('screenshotsBody').innerHTML = '';
        $('networkBody').innerHTML = '';
        $('locationsBody').innerHTML = '';
        $('appsBody').innerHTML = '';
        $('trackingBody').innerHTML = '';
        $('searchBody').innerHTML = '';
        $('summaryCard').style.display = 'none';
        $('sessionsCard').style.display = 'none';
        $('sessionsBody').innerHTML = '';
        $('idleBody').innerHTML = '';
        // Reset badge counts
        ['errors', 'warnings', 'screenshots', 'network', 'locations', 'apps', 'injected', 'tracking', 'search', 'sessions'].forEach(s => {
          const badge = $(s + 'Count');
          if (badge) badge.textContent = '0';
        });
        $('injectedBody').innerHTML = '';
        return;
      }

      // Calculate total tracked time
      const totalTrackedSecs = data.sessions.reduce((sum, s) => sum + (s.duration || 0), 0);

      $('kpiTotal').textContent = data.total.toLocaleString();
      $('kpiErrors').textContent = data.errors.length;
      $('kpiWarnings').textContent = data.warnings.length;
      $('kpiTrackedTime').textContent = fmtDuration(totalTrackedSecs);
      $('kpiIdleKept').textContent = fmtDuration(data.idleKeptSecs);
      $('kpiIdleDisc').textContent = fmtDuration(data.idleDiscardedSecs);
      $('kpiTimezone').textContent = data.timezone || 'Unknown';
      $('kpiTimezone').style.fontSize = data.timezone ? '18px' : '14px';

      // Update badge counts
      $('errorsCount').textContent = data.errors.length;
      $('warningsCount').textContent = data.warnings.length;
      $('screenshotsCount').textContent = data.screenshots.length;
      $('networkCount').textContent = data.network.length;
      $('locationsCount').textContent = data.locations.length;
      $('appsCount').textContent = data.apps.length;
      $('injectedCount').textContent = data.injected.length;
      $('trackingCount').textContent = data.tracking.length;
      $('sessionsCount').textContent = data.sessions.length;

      // Update badge colors based on counts
      $('errorsCount').className = 'badge ' + (data.errors.length > 0 ? 'danger' : '');
      $('warningsCount').className = 'badge ' + (data.warnings.length > 0 ? 'warn' : '');
      $('networkCount').className = 'badge ' + (data.network.length > 0 ? 'warn' : '');
      $('injectedCount').className = 'badge ' + (data.injected.length > 0 ? 'warn' : '');

      if (data.startTime && data.endTime) {
        const diffMs = data.endTime - data.startTime;
        const hrs = Math.floor(diffMs / 3600000);
        const mins = Math.floor((diffMs % 3600000) / 60000);
        $('kpiTimeSpan').textContent = hrs > 0 ? `${hrs}h ${mins}m` : `${mins}m`;
      } else {
        $('kpiTimeSpan').textContent = '--';
      }

      // Generate and render device dashboard
      const deviceStatus = generateDeviceDashboard(data);
      renderDeviceDashboard(deviceStatus);
      
      // Generate and render root cause conclusion
      if (plainMode) {
        const conclusion = generateRootCauseConclusion(deviceStatus, data);
        $('rootCauseCard').innerHTML = conclusion.html;
        $('rootCauseCard').style.display = 'block';
      } else {
        $('rootCauseCard').style.display = 'none';
      }

      // Generate and render summary if plain mode
      if (plainMode) {
        const findings = generateSummary(data);
        $('summaryCard').style.display = 'block';
        $('summaryContent').innerHTML = findings.map((f, i) => `
          <div class="summary-item ${f.severity}">
            <h4>${f.icon} ${f.title} ${f.techDetail ? `<span class="show-tech" onclick="toggleTech(${i})">Show technical</span>` : ''}</h4>
            <p>${f.description}</p>
            ${f.action ? `<div class="action">üí° <strong>What to do:</strong> ${f.action}</div>` : ''}
            ${f.techDetail ? `<div class="tech-detail" id="tech-${i}">${escapeHtml(f.techDetail)}</div>` : ''}
          </div>
        `).join('');
      } else {
        $('summaryCard').style.display = 'none';
      }

      // === RENDER SESSIONS TABLE ===
      if (data.sessions.length > 0) {
        $('sessionsCard').style.display = 'block';
        $('stopReasonLegend').style.display = plainMode ? 'block' : 'none';
        
        // Calculate log duration vs tracked time
        const logDurationSecs = data.startTime && data.endTime ? (data.endTime - data.startTime) / 1000 : 0;
        const totalTrackedSecs = data.sessions.reduce((sum, s) => sum + (s.duration || 0), 0);
        const hasShortUserStops = data.sessions.some(s => s.stopReason === 'USER' && s.duration < 60);
        
        // Show explainer if there's a big mismatch or short USER stops
        if (plainMode && (logDurationSecs > 600 && totalTrackedSecs < logDurationSecs * 0.1) || hasShortUserStops) {
          let explainerHtml = '<h4>üìñ Understanding These Results</h4>';
          
          if (logDurationSecs > 600 && totalTrackedSecs < logDurationSecs * 0.1) {
            explainerHtml += `
              <p><span class="key-point">Why does the log cover ${fmtDuration(logDurationSecs)} but only ${fmtDuration(totalTrackedSecs)} was tracked?</span></p>
              <p>The Hubstaff app continuously logs background activity (app focus, URLs, system status) even when the timer is <strong>not</strong> running. This is normal diagnostic behavior.</p>
              <ul>
                <li>Only time between START_TRACKING and STOP_TRACKING counts as billable time</li>
                <li>Background logs do NOT represent lost or missing time</li>
                <li>The ${fmtDuration(logDurationSecs)} log window includes all app activity, not just tracked time</li>
              </ul>
            `;
          }
          
          if (hasShortUserStops) {
            const shortSessions = data.sessions.filter(s => s.stopReason === 'USER' && s.duration < 60);
            explainerHtml += `
              <p><span class="key-point">What does "User stopped" mean?</span></p>
              <p>The stop was logged as a normal, user-initiated stop. This is <strong>not</strong> a crash or error.</p>
              <ul>
                <li>If the app had crashed ‚Üí we'd see "Crashed" or missing stop events</li>
                <li>If an error caused it ‚Üí we'd see error markers in the stop reason</li>
                <li>Network errors, high CPU, or timezone issues do NOT cause "User stopped" events</li>
              </ul>
              <p>If the user disputes stopping manually, possible explanations include: accidental click, trackpad sensitivity, another user, or remote access software.</p>
            `;
          }
          
          $('sessionExplainer').innerHTML = explainerHtml;
          $('sessionExplainer').style.display = 'block';
        } else {
          $('sessionExplainer').style.display = 'none';
        }
        
        $('sessionsBody').innerHTML = data.sessions.map((s, i) => {
          const stopReasonCls = s.stopReason === 'USER' ? 'success' : 
                                s.stopReason === 'IDLE' ? 'warn' : 
                                s.stopReason === 'CRASHED' || s.stopReason === 'LOG_END' ? 'error' :
                                s.stopReason === 'CONFIG' || s.stopReason === 'LEFT_JOBSITE' ? 'error' : 'info';
          const startReasonBadge = s.startReason === 'RESUMED' ? '<span class="tag audit" style="margin-left:4px;">RESUMED</span>' : '';
          
          let stopReasonText = s.stopReason;
          let stopReasonTooltip = '';
          if (plainMode) {
            if (s.stopReason === 'USER') {
              stopReasonText = 'User stopped';
              stopReasonTooltip = 'Logged as normal user stop. Not a crash or error.';
            }
            else if (s.stopReason === 'IDLE') stopReasonText = 'Went idle';
            else if (s.stopReason === 'CRASHED') stopReasonText = '‚ö†Ô∏è Crashed';
            else if (s.stopReason === 'LOG_END') stopReasonText = '‚ö†Ô∏è Still running?';
            else if (s.stopReason === 'CONFIG') stopReasonText = 'Config/Limit';
            else if (s.stopReason === 'LEFT_JOBSITE') stopReasonText = 'üìç Left Job Site';
            else if (s.stopReason === 'SHUTDOWN') stopReasonText = 'App closed';
          }
          
          const durationWarning = s.duration < 30 ? ' ‚ö°' : '';
          
          return `<tr>
            <td>${i + 1}${startReasonBadge}</td>
            <td>${fmtTime(s.start)}</td>
            <td>${s.stop ? fmtTime(s.stop) : '--'}</td>
            <td><span class="tag success">${fmtDuration(s.duration)}${durationWarning}</span></td>
            <td><span class="tag ${stopReasonCls}" ${stopReasonTooltip ? `title="${stopReasonTooltip}"` : ''}>${stopReasonText}</span></td>
          </tr>`;
        }).join('');
      } else {
        $('sessionsCard').style.display = 'block';
        $('sessionsBody').innerHTML = '<tr><td colspan="5" style="color:var(--muted)">No tracking sessions found in log</td></tr>';
        $('sessionExplainer').style.display = 'none';
        $('stopReasonLegend').style.display = 'none';
      }

      // === RENDER IDLE DECISIONS TABLE ===
      if (data.idleDecisions.length > 0) {
        $('idleBody').innerHTML = data.idleDecisions.map(d => {
          // Determine display class and text based on decision
          let decisionCls, actionText, actionIcon;
          if (d.decision === 'KEPT') {
            decisionCls = 'success';
            actionIcon = '‚úÖ';
            actionText = 'KEPT - User clicked YES';
          } else if (d.decision === 'DISCARDED_STOPPED') {
            decisionCls = 'error';
            actionIcon = 'üõë';
            actionText = 'DISCARDED + STOPPED tracking';
          } else {
            decisionCls = 'warn';
            actionIcon = '‚ùå';
            actionText = 'DISCARDED - User clicked NO';
          }
          
          // Add warning if exceeds 1 hour (idle time can't be kept)
          let durationNote = '';
          if (d.exceeds1Hour) {
            durationNote = ' <span style="color:var(--danger);font-size:10px;" title="Idle time exceeding 1 hour cannot be kept">‚ö†Ô∏è >1hr</span>';
          }
          
          // Response time (how long user took to answer the dialog)
          const responseTime = d.responseTimeSecs ? `${d.responseTimeSecs}s` : '‚Äî';
          
          return `<tr>
            <td>${fmtDate(d.ts)}</td>
            <td>${fmtDuration(d.seconds)}${durationNote}</td>
            <td style="color:var(--muted)">${responseTime}</td>
            <td><span class="tag ${decisionCls}">${plainMode ? (actionIcon + ' ' + actionText) : d.decision}</span></td>
            <td style="font-family:monospace;font-size:10px;color:var(--muted)">${d.rawValues || '‚Äî'}</td>
          </tr>`;
        }).join('');
      } else {
        $('idleBody').innerHTML = '<tr><td colspan="5" style="color:var(--muted)">No idle decisions recorded</td></tr>';
      }

      // Errors
      if (data.errors.length) {
        $('errorsList').innerHTML = data.errors.slice(0, 100).map(e => {
          const translation = plainMode ? translateToPlainEnglish(e.msg, e.level, e.src) : null;
          return `
            <div class="event-item">
              <div class="event-time">${fmtTime(e.ts)} ${renderLevelTag(e.level)}</div>
              ${translation ? `<div class="plain-explanation">${translation.text}</div>` : ''}
              <div class="event-detail" style="${plainMode ? 'font-size:10px;color:#666;' : ''}">${escapeHtml(e.msg.slice(0, 200))}</div>
              <div class="event-context">${escapeHtml(e.src)}</div>
            </div>
          `;
        }).join('');
      } else {
        $('errorsList').innerHTML = '<div class="event-item" style="color:var(--success)">‚úì No errors found</div>';
      }

      // Warnings
      if (data.warnings.length) {
        $('warningsList').innerHTML = data.warnings.slice(0, 100).map(e => {
          const translation = plainMode ? translateToPlainEnglish(e.msg, e.level, e.src) : null;
          return `
            <div class="event-item">
              <div class="event-time">${fmtTime(e.ts)} ${renderLevelTag(e.level)}</div>
              ${translation ? `<div class="plain-explanation">${translation.text}</div>` : ''}
              <div class="event-detail" style="${plainMode ? 'font-size:10px;color:#666;' : ''}">${escapeHtml(e.msg.slice(0, 200))}</div>
              <div class="event-context">${escapeHtml(e.src)}</div>
            </div>
          `;
        }).join('');
      } else {
        $('warningsList').innerHTML = '<div class="event-item" style="color:var(--success)">‚úì No warnings found</div>';
      }

      // Screenshots
      $('screenshotsBody').innerHTML = data.screenshots.slice(0, 50).map(e => `
        <tr>
          <td>${fmtTime(e.ts)}</td>
          <td>${renderLevelTag(e.level)}</td>
          <td style="font-size:11px;max-width:400px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(e.msg)}</td>
        </tr>
      `).join('') || '<tr><td colspan="3" style="color:var(--muted)">No screenshot events found</td></tr>';

      // Network
      $('networkBody').innerHTML = data.network.slice(0, 50).map(e => {
        let statusCls = 'info';
        if (e.msg.match(/Response:\s*[45]\d{2}/)) statusCls = 'error';
        else if (e.msg.includes('Error')) statusCls = 'error';
        return `
          <tr>
            <td>${fmtTime(e.ts)}</td>
            <td><span class="tag ${statusCls}">${e.level}</span></td>
            <td style="font-size:11px;max-width:400px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(e.msg)}</td>
          </tr>
        `;
      }).join('') || '<tr><td colspan="3" style="color:var(--muted)">No network issues found</td></tr>';

      // Locations
      // First render job sites summary if we have site data
      let locationsPreamble = '';
      
      if (data.jobSites.length > 0) {
        // Deduplicate sites by ID
        const uniqueSites = [...new Map(data.jobSites.map(s => [s.id, s])).values()];
        const radiusCounts = {};
        uniqueSites.forEach(s => {
          radiusCounts[s.radius] = (radiusCounts[s.radius] || 0) + 1;
        });
        const smallRadiusSites = uniqueSites.filter(s => s.radius <= 50);
        
        // Get user's most recent location
        const lastUserLoc = data.userLocations.length > 0 ? data.userLocations[data.userLocations.length - 1] : null;
        
        // Check if user was ever inside a site
        const enteredAnySite = data.currentlyEnteredSites.some(e => e.sites && e.sites.length > 0);
        
        locationsPreamble = `
          <div class="job-sites-summary">
            <h4>üìç Job Sites Configuration</h4>
            <div class="stats-row">
              <div class="stat"><span class="stat-value">${uniqueSites.length}</span><span class="stat-label">Total Sites</span></div>
              <div class="stat"><span class="stat-value">${Object.keys(radiusCounts).map(r => `${radiusCounts[r]}√ó${r}m`).join(', ')}</span><span class="stat-label">Radius Distribution</span></div>
              ${smallRadiusSites.length > 0 ? `<div class="stat"><span class="stat-value radius-small">‚ö†Ô∏è ${smallRadiusSites.length} sites with 50m radius</span></div>` : ''}
            </div>
            ${!enteredAnySite && data.currentlyEnteredSites.length > 0 ? `
              <div style="color:var(--warn); font-size:11px; margin-top:8px;">
                ‚ö†Ô∏è User was never detected inside any job site during this log period. All "currently entered sites" checks returned empty.
              </div>
            ` : ''}
            <details style="margin-top:10px;">
              <summary style="cursor:pointer; color:var(--accent); font-size:12px;">Show all ${uniqueSites.length} job sites</summary>
              <div class="job-sites-table">
                <table>
                  <thead><tr><th>Site Name</th><th>Radius</th><th>Coordinates</th></tr></thead>
                  <tbody>
                    ${uniqueSites.slice(0, 100).map(s => `
                      <tr>
                        <td style="max-width:250px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${escapeHtml(s.name)}">${escapeHtml(s.name)}</td>
                        <td><span class="${s.radius <= 50 ? 'radius-small' : 'radius-ok'}">${s.radius}m</span></td>
                        <td style="font-family:monospace;font-size:10px;">${s.lat.toFixed(4)}, ${s.lng.toFixed(4)}</td>
                      </tr>
                    `).join('')}
                    ${uniqueSites.length > 100 ? `<tr><td colspan="3" style="color:var(--muted)">... and ${uniqueSites.length - 100} more sites</td></tr>` : ''}
                  </tbody>
                </table>
              </div>
            </details>
          </div>
          ${lastUserLoc ? `
            <div class="user-location-box">
              <h4>üì± User's Last Known Location</h4>
              <div class="coords">${lastUserLoc.lat.toFixed(6)}, ${lastUserLoc.lng.toFixed(6)}</div>
              <div style="color:var(--muted); margin-top:4px;">Accuracy: ${lastUserLoc.accuracy}m at ${fmtTime(lastUserLoc.ts)}</div>
              ${lastUserLoc.accuracy > 50 ? `<div style="color:var(--warn); margin-top:4px;">‚ö†Ô∏è GPS accuracy is poor (${lastUserLoc.accuracy}m). This may affect job site detection.</div>` : ''}
            </div>
          ` : ''}
        `;
      }
      
      // Prepend job sites info to locations content
      const locationsContentEl = $('locationsContent');
      let existingPreamble = locationsContentEl.querySelector('.job-sites-summary');
      if (existingPreamble) existingPreamble.remove();
      let existingUserLoc = locationsContentEl.querySelector('.user-location-box');
      if (existingUserLoc) existingUserLoc.remove();
      
      if (locationsPreamble) {
        const preambleDiv = document.createElement('div');
        preambleDiv.innerHTML = locationsPreamble;
        locationsContentEl.insertBefore(preambleDiv, locationsContentEl.firstChild);
      }

      // Render visit history
      renderVisitHistory(data);
      
      $('locationsBody').innerHTML = data.locations.slice(0, 50).map(e => `
        <tr>
          <td>${fmtTime(e.ts)}</td>
          <td>${renderLevelTag(e.level)}</td>
          <td style="font-size:11px;max-width:400px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(e.msg)}</td>
        </tr>
      `).join('') || '<tr><td colspan="3" style="color:var(--muted)">No location events found</td></tr>';

      // Apps
$('appsBody').innerHTML = data.apps.slice(0, 100).map(e => {
  let type = e.extractedType || 'App';
  let content = '';
  
  if (e.extractedUrl) {
    content = e.extractedUrl;
  } else if (e.extractedTitle) {
    content = e.extractedTitle;
  } else if (e.extractedApp) {
    content = e.extractedApp;
  } else {
    // Fallback: try to extract from raw line
    const urlMatch = e.raw.match(/URL:\s*(\S+)/);
    const titleMatch = e.raw.match(/TITLE:\s*(.+)/);
    const appMatch = e.raw.match(/APP:\s*(.+)/);
    
    if (urlMatch && urlMatch[1]) {
      type = 'URL';
      content = urlMatch[1];
    } else if (titleMatch && titleMatch[1].trim()) {
      type = 'Title';
      content = titleMatch[1].trim();
    } else if (appMatch && appMatch[1].trim()) {
      type = 'App';
      content = appMatch[1].trim();
    } else {
      content = e.msg;
    }
  }
  
  // Skip if no meaningful content
  if (!content || content === 'TITLE:' || content.trim() === '') {
    return '';
  }
  
  // Check for Brave Browser - URL tracking not supported
  const isBrave = content.toLowerCase().includes('brave');
  const braveWarning = isBrave ? ' <span class="tag warn" title="Hubstaff does not support URL tracking in Brave Browser. Consider using Chrome, Edge, Firefox, or Island Browser instead." style="cursor:help;">‚ö†Ô∏è No URL tracking</span>' : '';
  
  const tagClass = type === 'URL' ? 'info' : type === 'Title' ? 'audit' : 'success';
  
  return `
    <tr>
      <td>${fmtTime(e.ts)}</td>
      <td><span class="tag ${tagClass}">${type}</span>${braveWarning}</td>
      <td style="font-size:11px;max-width:400px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;" title="${escapeHtml(content)}">${escapeHtml(content)}</td>
    </tr>
  `;
}).filter(row => row !== '').join('') || '<tr><td colspan="3" style="color:var(--muted)">No app/URL events found</td></tr>';

// Update apps count to reflect actual valid entries (excluding empty ones)
const actualAppsCount = data.apps.filter(e => {
  if (e.extractedUrl || e.extractedTitle || e.extractedApp) return true;
  const urlMatch = e.raw.match(/URL:\s*(\S+)/);
  return urlMatch && urlMatch[1];
}).length;
$('appsCount').textContent = actualAppsCount;

      // Injected Input
      $('injectedBody').innerHTML = data.injected.slice(0, 100).map(e => {
        let type = 'Injected';
        if (e.msg.toLowerCase().includes('simulated')) type = 'Simulated';
        else if (e.msg.toLowerCase().includes('partially')) type = 'Partial';
        else if (e.msg.toLowerCase().includes('only injected')) type = 'Only Injected';
        return `
          <tr>
            <td>${fmtTime(e.ts)}</td>
            <td><span class="tag warn">${type}</span></td>
            <td style="font-size:11px;max-width:400px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(e.msg)}</td>
          </tr>
        `;
      }).join('') || '<tr><td colspan="3" style="color:var(--success)">‚úì No injected input detected</td></tr>';

      // Tracking
      $('trackingBody').innerHTML = data.tracking.slice(0, 50).map(e => {
        let eventType = 'Event';
        if (e.msg.includes('Resume')) eventType = 'Resume';
        else if (e.msg.includes('Idle')) eventType = 'Idle';
        else if (e.msg.includes('Discard')) eventType = 'Discard';
        else if (e.msg.includes('Startup')) eventType = 'Startup';
        else if (e.msg.includes('START_TRACKING')) eventType = 'Start';
        else if (e.msg.includes('STOP_TRACKING')) eventType = 'Stop';
        const typeCls = eventType === 'Discard' ? 'warn' : eventType === 'Resume' ? 'success' : 'info';
        return `
          <tr>
            <td>${fmtTime(e.ts)}</td>
            <td><span class="tag ${typeCls}">${eventType}</span></td>
            <td style="font-size:11px;max-width:400px;overflow:hidden;text-overflow:ellipsis;white-space:nowrap;">${escapeHtml(e.msg)}</td>
          </tr>
        `;
      }).join('') || '<tr><td colspan="3" style="color:var(--muted)">No tracking events found</td></tr>';

      // Render timeline
      renderTimeline(data);
    }

    function search(query) {
      if (!query.trim()) {
        $('searchBody').innerHTML = '<tr><td colspan="4" style="color:var(--muted)">Enter a search term above</td></tr>';
        $('searchCount').textContent = '0';
        return;
      }

      const q = query.toLowerCase();
      const results = allLines.filter(line => line.toLowerCase().includes(q)).slice(0, 200);

      $('searchCount').textContent = results.length;
      
      // Auto-expand search section when searching
      expandSection('search');

      if (!results.length) {
        $('searchBody').innerHTML = `<tr><td colspan="4" style="color:var(--muted)">No results for "${escapeHtml(query)}"</td></tr>`;
        return;
      }

      $('searchBody').innerHTML = results.map(line => {
        const ts = parseTimestamp(line);
        const level = parseLevel(line);
        const src = parseSource(line);
        const msg = parseMessage(line);
        const highlightedMsg = escapeHtml(msg).replace(new RegExp(`(${escapeHtml(query)})`, 'gi'), '<mark class="highlight">$1</mark>');
        return `
          <tr>
            <td style="white-space:nowrap;">${fmtTime(ts)}</td>
            <td>${renderLevelTag(level)}</td>
            <td style="font-size:10px;color:var(--muted);max-width:100px;overflow:hidden;text-overflow:ellipsis;">${escapeHtml(src)}</td>
            <td style="font-size:11px;">${highlightedMsg}</td>
          </tr>
        `;
      }).join('');
    }

    $('analyzeBtn').onclick = () => {
      const text = $('logInput').value;
      if (!text.trim()) {
        $('status').textContent = 'Please paste log content first';
        $('status').className = 'status error';
        return;
      }

      let lines = text.split(/\r?\n/);
      const originalCount = lines.filter(l => l.trim()).length;
      
      if ($('autoFilter').checked) {
        lines = filterLogs(lines);
        const filteredCount = lines.length;
        const removedCount = originalCount - filteredCount;
        const pct = originalCount > 0 ? ((removedCount / originalCount) * 100).toFixed(1) : 0;
        $('filterStats').style.display = 'block';
        $('filterStatsText').innerHTML = `üîÆ <strong>Filtered:</strong> ${originalCount.toLocaleString()} ‚Üí ${filteredCount.toLocaleString()} lines (removed ${removedCount.toLocaleString()} noise lines, ${pct}%)`;
      } else {
        $('filterStats').style.display = 'none';
      }

      fullParsedData = analyze(lines.join('\n'));
      parsedData = filterByDate(fullParsedData);
      render(parsedData);
      $('status').textContent = `Analyzed ${parsedData.total.toLocaleString()} lines`;
      $('status').className = 'status success';
    };

    $('clearBtn').onclick = () => {
      $('logInput').value = '';
      $('searchInput').value = '';
      allLines = [];
      parsedData = null;
      timelineMin = null;
      timelineDur = null;
      render(null);
      $('timelineSection').style.display = 'none';
      $('filterStats').style.display = 'none';
      $('deviceDashboard').style.display = 'none';
      $('rootCauseCard').style.display = 'none';
      $('visitHistorySection').innerHTML = '';
      $('dateFrom').value = '';
      $('dateTo').value = '';
      fullParsedData = null;
      hideInfoBox();
      $('status').textContent = 'üîí All data cleared';
      $('status').className = 'status success';
      setTimeout(() => { $('status').textContent = ''; }, 2000);
    };

    $('searchBtn').onclick = () => search($('searchInput').value);
    $('searchInput').onkeydown = e => { if (e.key === 'Enter') search($('searchInput').value); };
    $('clearSearchBtn').onclick = () => {
      $('searchInput').value = '';
      $('searchBody').innerHTML = '<tr><td colspan="4" style="color:var(--muted)">Enter a search term above</td></tr>';
    };

    $('showDebug').onchange = () => { if (parsedData) { parsedData = analyze($('logInput').value); render(parsedData); } };
    $('showTrace').onchange = () => { if (parsedData) { parsedData = analyze($('logInput').value); render(parsedData); } };
    $('plainMode').onchange = () => { if (parsedData) render(parsedData); };

    // Timezone controls
    $('tzOffset').oninput = () => { 
      updateTzLabel(); 
      if ($('userTzMode').checked && fullParsedData) {
        parsedData = filterByDate(fullParsedData);
        render(parsedData);
      }
    };
    $('userTzMode').onchange = () => {
      if ($('userTzMode').checked && userTzOffsetMs === null) {
        $('tzOffset').focus();
        $('tzOffset').style.borderColor = 'var(--warn)';
        setTimeout(() => { $('tzOffset').style.borderColor = ''; }, 1500);
      }
      if (fullParsedData) {
        parsedData = filterByDate(fullParsedData);
        render(parsedData);
      }
    };
    
    // Date filter controls
    $('dateFrom').onchange = () => { 
      if (fullParsedData) { 
        parsedData = filterByDate(fullParsedData); 
        render(parsedData); 
      } 
    };
    $('dateTo').onchange = () => { 
      if (fullParsedData) { 
        parsedData = filterByDate(fullParsedData); 
        render(parsedData); 
      } 
    };
    $('clearDates').onclick = () => { 
      $('dateFrom').value = ''; 
      $('dateTo').value = ''; 
      if (fullParsedData) { 
        parsedData = filterByDate(fullParsedData); 
        render(parsedData); 
      } 
    };

    // Toggle technical details in summary
    window.toggleTech = function(idx) {
      const el = $('tech-' + idx);
      if (el) el.classList.toggle('visible');
    };

    // Toggle collapsible sections
    window.toggleSection = function(section) {
      const header = document.querySelector(`#${section}Content`).previousElementSibling;
      const content = $(`${section}Content`);
      header.classList.toggle('collapsed');
      content.classList.toggle('collapsed');
    };

    // Toggle filter details
    window.toggleFilterDetails = function() {
      const details = $('filterDetails');
      const toggle = $('filterDetailsToggle');
      if (details.style.display === 'none') {
        details.style.display = 'block';
        toggle.textContent = 'Hide details';
      } else {
        details.style.display = 'none';
        toggle.textContent = 'What was removed?';
      }
    };

    // Expand section (used when searching)
    function expandSection(section) {
      const header = document.querySelector(`#${section}Content`).previousElementSibling;
      const content = $(`${section}Content`);
      header.classList.remove('collapsed');
      content.classList.remove('collapsed');
    }

   // Help Guide functionality
    $('helpGuideBtn').onclick = () => $('helpModal').classList.add('visible');
    $('closeHelp').onclick = () => $('helpModal').classList.remove('visible');
    $('helpModal').onclick = e => { if (e.target === $('helpModal')) $('helpModal').classList.remove('visible'); };

    // Help Guide navigation
    document.querySelectorAll('.help-nav-btn').forEach(btn => {
      btn.onclick = () => {
        document.querySelectorAll('.help-nav-btn').forEach(b => b.classList.remove('active'));
        document.querySelectorAll('.help-section').forEach(s => s.classList.remove('active'));
        btn.classList.add('active');
        const section = document.getElementById('help-' + btn.dataset.section);
        if (section) section.classList.add('active');
      };
    });

    $('privacyBtn').onclick = () => $('privacyModal').classList.add('visible');
    $('closePrivacy').onclick = () => $('privacyModal').classList.remove('visible');
    $('privacyModal').onclick = e => { if (e.target === $('privacyModal')) $('privacyModal').classList.remove('visible'); };

    // Timeline zoom controls
    $('zoomSlider').oninput = function() {
      $('timelineContent').style.width = (this.value * 100) + '%';
    };

    $('resetZoom').onclick = () => {
      $('zoomSlider').value = 1;
      $('timelineContent').style.width = '100%';
      $('timelineContainer').scrollLeft = 0;
      hideInfoBox();
    };

    // Close info box on click outside
    document.addEventListener('click', e => {
      if (!e.target.closest('.info-box') && !e.target.closest('.t-marker')) {
        hideInfoBox();
      }
    });

    // Timeline track toggles
    const trackToggles = [
      { toggle: 'togErrors', label: 'labelErrors', track: 'trackErrors' },
      { toggle: 'togWarnings', label: 'labelWarnings', track: 'trackWarnings' },
      { toggle: 'togScreenshots', label: 'labelScreenshots', track: 'trackScreenshots' },
      { toggle: 'togNetwork', label: 'labelNetwork', track: 'trackNetwork' },
      { toggle: 'togLocation', label: 'labelLocation', track: 'trackLocation' },
      { toggle: 'togTracking', label: 'labelTracking', track: 'trackTracking' },
    ];

    trackToggles.forEach(({ toggle, label, track }) => {
      $(toggle).onchange = function() {
        const isVisible = this.checked;
        $(label).classList.toggle('hidden', !isVisible);
        $(track).classList.toggle('hidden', !isVisible);
        this.parentElement.classList.toggle('disabled', !isVisible);
      };
    });

    document.addEventListener('keydown', e => {
      if ((e.metaKey || e.ctrlKey) && e.key === 'Enter') {
        e.preventDefault();
        $('analyzeBtn').click();
      }
    });

    // Clear all data when page is closed
    window.addEventListener('beforeunload', () => {
      $('logInput').value = '';
      if (allLines) allLines.length = 0;
      if (parsedData) {
        if (parsedData.errors) parsedData.errors.length = 0;
        if (parsedData.warnings) parsedData.warnings.length = 0;
        if (parsedData.screenshots) parsedData.screenshots.length = 0;
        if (parsedData.network) parsedData.network.length = 0;
        if (parsedData.locations) parsedData.locations.length = 0;
        if (parsedData.apps) parsedData.apps.length = 0;
        if (parsedData.tracking) parsedData.tracking.length = 0;
        if (parsedData.sessions) parsedData.sessions.length = 0;
        if (parsedData.idleDecisions) parsedData.idleDecisions.length = 0;
      }
      parsedData = null;
      allLines = [];
    });
  </script>
</body>
</html>
